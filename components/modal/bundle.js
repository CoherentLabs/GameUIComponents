/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./components/modal/demo/demo.js":
/*!***************************************!*\
  !*** ./components/modal/demo/demo.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"demo\": () => (/* binding */ demo)\n/* harmony export */ });\n/* harmony import */ var coherent_gameface_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! coherent-gameface-components */ \"./lib/components.js\");\n/* harmony import */ var _umd_modal_development_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../umd/modal.development.js */ \"./components/modal/umd/modal.development.js\");\n/* harmony import */ var _umd_modal_development_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_umd_modal_development_js__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable no-unused-vars */\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Coherent Labs AD. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n/**\r\n * Class definition of the demo\r\n */\r\nclass Demo {\r\n    // eslint-disable-next-line require-jsdoc\r\n    constructor() {\r\n        this.saveButton = document.querySelector('.save');\r\n        this.confirmButton = document.querySelector('#confirm');\r\n        this.nameField = document.querySelector('input[for=\"name\"]');\r\n\r\n        this.attachEventListeners();\r\n    }\r\n\r\n    /**\r\n     * Handler when the save button is clicked\r\n     */\r\n    onSaveName() {\r\n        document.getElementsByTagName('gameface-modal')[0].style.display = 'flex';\r\n    };\r\n\r\n    /**\r\n     * Attach listeners to all the modal buttons\r\n     */\r\n    attachEventListeners() {\r\n        this.confirmButton.addEventListener('click', this.onConfirm);\r\n\r\n        this.nameField.addEventListener('keyup', (e) => {\r\n            if (this.nameField.value) {\r\n                this.saveButton.classList.remove('disabled');\r\n                this.saveButton.addEventListener('click', this.onSaveName);\r\n                return;\r\n            }\r\n            this.saveButton.removeEventListener('click', this.onSaveName);\r\n            this.saveButton.classList.add('disabled');\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handler when the confirm button is clicked\r\n     * @returns {void}\r\n     */\r\n    onConfirm() {\r\n        const modal = document.getElementsByTagName('gameface-modal')[0];\r\n        const nameText = document.querySelector('.name-text');\r\n        const nameField = document.querySelector('input[for=\"name\"]');\r\n\r\n        if (!nameText || !nameField) return modal.close();\r\n        document.querySelector('.name').textContent = nameField.value;\r\n        modal.close();\r\n\r\n        nameText.classList.remove('hidden');\r\n        nameText.querySelector('.name').textContent = nameField.value;\r\n    }\r\n}\r\n\r\nconst demo = new Demo();\r\n\r\n\r\n\n\n//# sourceURL=webpack://gameuicomponents/./components/modal/demo/demo.js?");

/***/ }),

/***/ "./components/modal/umd/modal.development.js":
/*!***************************************************!*\
  !*** ./components/modal/umd/modal.development.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! coherent-gameface-components */ \"./lib/components.js\")) :\n    0;\n})(this, (function (exports, components) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var components__default = /*#__PURE__*/_interopDefaultLegacy(components);\n\n    var template = \"<!--Copyright (c) Coherent Labs AD. All rights reserved. Licensed under the MIT License. See License.txt in the project root for license information. -->\\r\\n<div class=\\\"guic-modal-wrapper\\\">\\r\\n    <div class=\\\"guic-modal-backdrop\\\"></div>\\r\\n    <div class=\\\"guic-modal\\\">\\r\\n        <div class=\\\"close guic-modal-close-x\\\">x</div>\\r\\n        <div class=\\\"guic-modal-header\\\">\\r\\n            <component-slot data-name=\\\"header\\\">Put your title here.</component-slot>\\r\\n        </div>\\r\\n        <div class=\\\"guic-modal-body\\\">\\r\\n            <component-slot data-name=\\\"body\\\">Put the content here.</component-slot>\\r\\n        </div>\\r\\n        <div class=\\\"guic-modal-footer\\\">\\r\\n            <component-slot data-name=\\\"footer\\\">Put your actions here.</component-slot>\\r\\n        </div>\\r\\n    </div>\\r\\n</div>\\r\\n\";\n\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Coherent Labs AD. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Class definition of the gameface modal custom element\r\n     */\r\n    class Modal extends HTMLElement {\r\n        // eslint-disable-next-line require-jsdoc\r\n        constructor() {\r\n            super();\r\n\r\n            this.template = template;\r\n\r\n            this.state = { display: 'none' };\r\n\r\n            this.closeBound = e => this.close(e);\r\n            this.url = '/components/modal/template.html';\r\n        }\r\n\r\n        // eslint-disable-next-line require-jsdoc\r\n        connectedCallback() {\r\n            components__default[\"default\"].loadResource(this)\r\n                .then((result) => {\r\n                    this.template = result.template;\r\n                    components__default[\"default\"].renderOnce(this);\r\n                    this.attachEventListeners();\r\n                })\r\n                .catch(err => console.error(err));\r\n        }\r\n\r\n        /**\r\n         * Method that will attach click event listeners to all close buttons\r\n         */\r\n        attachEventListeners() {\r\n            const closeButtons = this.querySelectorAll('.close');\r\n            for (let i = 0; i < closeButtons.length; i++) {\r\n                closeButtons[i].addEventListener('click', this.closeBound);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Handler for closing the modal\r\n         */\r\n        close() {\r\n            this.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    components__default[\"default\"].defineCustomElement('gameface-modal', Modal);\n\n    exports.Modal = Modal;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n//# sourceURL=webpack://gameuicomponents/./components/modal/umd/modal.development.js?");

/***/ }),

/***/ "./lib/components.js":
/*!***************************!*\
  !*** ./lib/components.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Coherent Labs AD. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nconst newLinesRegExp = new RegExp('^\\s+|\\s+$', 'g');\r\nconst NATIVE_TEXT_FIELD_ELEMENTS = ['input', 'textarea'];\r\n\r\n/**\r\n * Checks if the passed element is a native text field\r\n * @param {HTMLElement} element\r\n * @returns {boolean}\r\n */\r\nfunction isNativeTextField(element) {\r\n    return NATIVE_TEXT_FIELD_ELEMENTS.indexOf(element.tagName.toLowerCase()) > -1;\r\n}\r\n\r\n// eslint-disable-next-line max-lines-per-function, require-jsdoc\r\nconst components = function () {\r\n    /**\r\n     * This is the base class that holds all functionality shared between custom components\r\n     * and native elements\r\n     */\r\n    class Validator {\r\n        /**\r\n         * Check if element is child of a form\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static isFormElement(element) {\r\n            element = element.parentElement;\r\n            while (element) {\r\n                if (element.tagName === 'GAMEFACE-FORM-CONTROL' || element.tagName === 'gameface-form-control') return true;\r\n                element = element.parentElement;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check if element value is bigger than element maxlength\r\n         * @returns {boolean}\r\n         */\r\n        static tooLong() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check if element value is less than element minlength\r\n         * @returns {boolean}\r\n         */\r\n        static tooShort() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if the value of an element is bigger than its max attribute\r\n         * @returns {boolean}\r\n        */\r\n        static rangeOverflow() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if the value of an element is smaller than its min attribute\r\n         * @returns {boolean}\r\n        */\r\n        static rangeUnderflow() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check if element is required and its value is missing\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static valueMissing(element) {\r\n            return element.hasAttribute('required') && !element.value;\r\n        }\r\n\r\n        /**\r\n         * Check if element name is missing\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static nameMissing(element) {\r\n            return !element.name && !element.getAttribute('name');\r\n        }\r\n\r\n        /**\r\n         * Check if an element is required\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n        */\r\n        static isRequired(element) {\r\n            return element.hasAttribute('required');\r\n        }\r\n\r\n        /**\r\n         * Checks if there is a custom error for the element\r\n         * @returns {boolean}\r\n         */\r\n        static customError() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if element is going to be serialized.\r\n         * If an element doesn't have a name it will not be serialized.\r\n         * Used to determine if an element should be validated.\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n        */\r\n        static willSerialize(element) {\r\n            return this.nameMissing(element) ? false : true;\r\n        }\r\n\r\n        /* eslint-disable require-jsdoc */\r\n        static isBadURL() {\r\n            return false;\r\n        }\r\n\r\n        static isBadEmail() {\r\n            return false;\r\n        }\r\n        /* eslint-enable require-jsdoc */\r\n    }\r\n\r\n    /**\r\n     * The NativeElementValidator uses the methods from the Validator class\r\n     * All native elements tha don't support methods like isFormElement, tooLong, tooShort\r\n     * etc.. will be wrapped in this class in order to enable us to validate native and\r\n     * custom elements using the same methods.\r\n     * */\r\n    class NativeElementValidator {\r\n        /* eslint-disable require-jsdoc */\r\n\r\n        constructor(element) {\r\n            this.element = element;\r\n        }\r\n\r\n        isFormElement() {\r\n            return Validator.isFormElement(this.element);\r\n        }\r\n\r\n        tooLong() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.tooLong(this.element);\r\n            return Validator.tooLong();\r\n        }\r\n\r\n        tooShort() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.tooShort(this.element);\r\n            return Validator.tooShort();\r\n        }\r\n\r\n        rangeOverflow() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.rangeOverflow(this.element);\r\n            return Validator.rangeOverflow();\r\n        }\r\n\r\n        rangeUnderflow() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.rangeUnderflow(this.element);\r\n            return Validator.rangeUnderflow();\r\n        }\r\n\r\n        valueMissing() {\r\n            return Validator.valueMissing(this.element);\r\n        }\r\n\r\n        nameMissing() {\r\n            return Validator.nameMissing(this.element);\r\n        }\r\n\r\n        customError() {\r\n            return Validator.customError();\r\n        }\r\n\r\n        isRequired() {\r\n            return Validator.isRequired(this.element);\r\n        }\r\n\r\n        willSerialize() {\r\n            return Validator.willSerialize(this.element);\r\n        }\r\n\r\n        isBadEmail() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.isBadEmail(this.element);\r\n            return false;\r\n        }\r\n\r\n        isBadURL() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.isBadURL(this.element);\r\n            return false;\r\n        }\r\n        /* eslint-enable require-jsdoc */\r\n    }\r\n\r\n    /**\r\n     * The CustomElementValidator is inherited by custom elements in order to gain the\r\n     * validation function from the Validator class.\r\n     * This class can not be used to wrap the native elements as it inherits the\r\n     * HTMLElement which can not be instantiated using the new keyword.\r\n    */\r\n    class CustomElementValidator extends HTMLElement {\r\n        /* eslint-disable require-jsdoc */\r\n\r\n        isFormElement() {\r\n            return Validator.isFormElement(this);\r\n        }\r\n\r\n        tooLong() {\r\n            return Validator.tooLong(this);\r\n        }\r\n\r\n        tooShort() {\r\n            return Validator.tooShort(this);\r\n        }\r\n\r\n        valueMissing() {\r\n            return Validator.valueMissing(this);\r\n        }\r\n\r\n        nameMissing() {\r\n            return Validator.nameMissing(this);\r\n        }\r\n\r\n        customError() {\r\n            return Validator.customError();\r\n        }\r\n\r\n        isRequired() {\r\n            return Validator.isRequired(this);\r\n        }\r\n\r\n        rangeOverflow() {\r\n            return Validator.rangeOverflow(this);\r\n        }\r\n\r\n        rangeUnderflow() {\r\n            return Validator.rangeUnderflow(this);\r\n        }\r\n\r\n        willSerialize() {\r\n            return Validator.willSerialize(this);\r\n        }\r\n\r\n        isBadEmail() {\r\n            return Validator.isBadEmail(this);\r\n        }\r\n\r\n        isBadURL() {\r\n            return Validator.isBadURL(this);\r\n        }\r\n        /* eslint-enable require-jsdoc */\r\n    }\r\n\r\n    /**\r\n     * Class that implements the commong validation methods for the text fields\r\n     */\r\n    class TextFieldValidator {\r\n        /**\r\n         * Most of the custom elements will not need this check however,\r\n         * we call all validation methods in order to determine if an element is valid.\r\n         * Each element that needs this check implements it itself.\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static tooLong(element) {\r\n            const maxLength = element.getAttribute('maxlength');\r\n            if (!maxLength) return false;\r\n            return element.value.length > parseFloat(maxLength);\r\n        }\r\n\r\n        /**\r\n        * Most of the custom elements will not need this check however,\r\n        * we call all validation methods in order to determine if an element is valid.\r\n        * Each element that needs this check implements it itself.\r\n        * @param {HTMLElement} element\r\n        * @returns {boolean}\r\n        */\r\n        static tooShort(element) {\r\n            const minLength = element.getAttribute('minlength');\r\n            if (!minLength) return false;\r\n            return element.value.length < parseFloat(minLength);\r\n        }\r\n\r\n        /**\r\n        * Most of the custom elements will not need this check however,\r\n        * we call all validation methods in order to determine if an element is valid.\r\n        * Each element that needs this check implements it itself.\r\n        * @param {HTMLElement} element\r\n        * @returns {boolean}\r\n        */\r\n        static rangeOverflow(element) {\r\n            const max = element.getAttribute('max');\r\n            if (!max) return false;\r\n            return parseFloat(element.value) > parseFloat(max);\r\n        }\r\n\r\n        /**\r\n         * Most of the custom elements will not need this check however,\r\n         * we call all validation methods in order to determine if an element is valid.\r\n         * Each element that needs this check implements it itself.\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static rangeUnderflow(element) {\r\n            const min = element.getAttribute('min');\r\n            if (!min) return false;\r\n            return parseFloat(element.value) < parseFloat(min);\r\n        }\r\n\r\n        /**\r\n         * Checks if the text field with type url has a valid url by its pattern\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static isBadURL(element) {\r\n            if (element.getAttribute('type') !== 'url') return false;\r\n            const pattern = element.pattern || element.getAttribute('pattern');\r\n            if (!pattern) return false;\r\n            if (!element.value.match(pattern)) return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if the text field element with type email is valid\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static isBadEmail(element) {\r\n            if (element.getAttribute('type') !== 'email') return false;\r\n            if (!element.value.match('@')) return true;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    const GF_COMPONENT_SLOT_TAG_NAME = 'component-slot';\r\n    const KEYCODES = {\r\n        DOWN: 40,\r\n        LEFT: 37,\r\n        RIGHT: 39,\r\n        UP: 38,\r\n        HOME: 36,\r\n        END: 35,\r\n        ENTER: 13,\r\n        ESCAPE: 27,\r\n        TAB: 9,\r\n        SHIFT: 16,\r\n        CTRL: 17,\r\n        SPACE: 32,\r\n        PAGE_UP: 33,\r\n        PAGE_DOWN: 34,\r\n        LETTER_A: 65,\r\n    };\r\n\r\n    /**\r\n     * Class that defines the Gameface components\r\n     */\r\n    class GamefaceComponents {\r\n        // eslint-disable-next-line require-jsdoc\r\n        constructor() {\r\n            this.definedElements = {};\r\n            this.imported = this.imported || [];\r\n            this.KEYCODES = KEYCODES;\r\n            this.cachedComponents = {};\r\n\r\n            this.CustomElementValidator = CustomElementValidator;\r\n            this.NativeElementValidator = NativeElementValidator;\r\n            this.TextFieldValidator = TextFieldValidator;\r\n            this.Validator = Validator;\r\n        }\r\n\r\n        /**\r\n         * Create and add a script tag with given url.\r\n         * @param {string} url\r\n        */\r\n        importScript(url) {\r\n            const script = document.createElement('script');\r\n            script.setAttribute('src', url);\r\n            document.body.appendChild(script);\r\n        }\r\n\r\n        /**\r\n         * Loads an html by given url.\r\n         * @param {string} url\r\n         * @returns {promise} resolved with the html as text.\r\n        */\r\n        loadHTML(url) {\r\n            return this.loadResource(url).then((result) => {\r\n                return result.template;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Creates a promise which resolves when a custom element was defined.\r\n         * Saves the promise for each defined component.\r\n         * @param {string} name - the name of the custom element\r\n         * @returns {promise} - the previously saved promise it any or a new one\r\n        */\r\n        whenDefined(name) {\r\n            if (this.definedElements[name] !== undefined) {\r\n                return this.definedElements[name].promise;\r\n            }\r\n\r\n            const defined = this.definedElements[name] = {};\r\n            defined.promise = new Promise((resolve, reject) => {\r\n                defined.resolve = resolve;\r\n                defined.reject = reject;\r\n            });\r\n            return defined.promise;\r\n        }\r\n\r\n        /**\r\n         * Defines a custom element.\r\n         * @param {string} name - the name of the element.\r\n         * @param {Object} element - the object which describes the element.\r\n        */\r\n        defineCustomElement(name, element) {\r\n            if (this.definedElements[name]) return;\r\n            this.whenDefined(name);\r\n            customElements.define(name, element);\r\n            this.definedElements[name].resolve(element);\r\n        }\r\n\r\n        /**\r\n         * Imports a component by given url.\r\n         * It will automatically try to import style.css and script.js if these\r\n         * files' names were not explicitly specified.\r\n         * @param {string} url - the url of the component\r\n        */\r\n        importComponent(url) {\r\n            requestAnimationFrame(() => {\r\n                this.importScript(url + '/script.js');\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Removes back and forward slashes from string\r\n         * @param {string} path\r\n         * @returns {string}\r\n         */\r\n        removeSlashes(path) {\r\n            return path.replace(/[/|\\\\]/g, '');\r\n        }\r\n\r\n        /**\r\n         * Remove new lines from the beginning of templates,\r\n         * because template.firstChild.cloneNode will clone an empty\r\n         * string and will return an empty template.\r\n         * @param {string} template\r\n         * @returns {string}\r\n        */\r\n        removeNewLines(template) {\r\n            return template.replace(newLinesRegExp, '').trim();\r\n        }\r\n\r\n        /**\r\n         * Removes the copyright notice from the template\r\n         * @param {string} template\r\n         * @returns {string} the template without the copyright notice\r\n        */\r\n        removeCopyrightNotice(template) {\r\n            return template.replace(`<!--Copyright (c) Coherent Labs AD. All rights reserved. Licensed under the MIT License. See License.txt in the project root for license information. -->`, '').trim();\r\n        }\r\n\r\n        /**\r\n         * Used when the element has already been rendered.\r\n         * Return the already rendered template instead of\r\n         * loading and slotting its elements.\r\n         *\r\n         * @param {HTMLElement} component - the component that was rendered\r\n         * @returns {Promise<HTMLElement>} - a promise that will resolve with the rendered template\r\n        */\r\n        resolveWithTemplate(component) {\r\n            return new Promise((resolve) => {\r\n                resolve({\r\n                    template: component.template.cloneNode(true),\r\n                    url: component.url,\r\n                });\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Uses an XMLHttpRequest to load an external file.\r\n         * @param {string} component - the url of the file.\r\n         * @returns {promise} - a promise that is resolved with the file's text content.\r\n        */\r\n        loadResource(component) {\r\n            if (component.template && typeof component.template === 'string') {\r\n                if (component.isRendered) return this.resolveWithTemplate(component);\r\n                const element = document.createElement('div');\r\n                const template = this.removeCopyrightNotice(component.template);\r\n                element.innerHTML = this.removeNewLines(template);\r\n\r\n                return new Promise((resolve) => {\r\n                    resolve({\r\n                        template: element.firstChild.cloneNode(true),\r\n                        url: component.url,\r\n                    });\r\n                });\r\n            }\r\n\r\n            if (typeof component.template === 'object' && component.isRendered) {\r\n                return this.resolveWithTemplate(component);\r\n            }\r\n\r\n            if (window.__optimize) {\r\n                const id = this.removeSlashes(component.url);\r\n                const element = document.getElementById(id).firstChild;\r\n                // fallback to XHR\r\n                if (!element) return this.requestResource(component.url);\r\n\r\n                return new Promise((resolve) => {\r\n                    resolve({ template: element.cloneNode(true), url: component.url });\r\n                });\r\n            }\r\n\r\n            return this.requestResource(component.url);\r\n        }\r\n\r\n\r\n        /**\r\n         * Execute an XMLHttpRequest to load a resource by url.\r\n         * @param {string} url - the path to the resource\r\n         * @returns {promise} - promise which resolves with the loaded resource\r\n        */\r\n        requestResource(url) {\r\n            const request = new XMLHttpRequest();\r\n            const promise = new Promise(function (resolve, reject) {\r\n                request.onload = (response) => {\r\n                    if (request.status == 200) {\r\n                        const tempEl = document.createElement('div');\r\n                        tempEl.innerHTML = request.responseText;\r\n                        resolve({ template: tempEl.firstChild.cloneNode(true), url: url });\r\n                    } else {\r\n                        reject(response);\r\n                    }\r\n                };\r\n                request.onerror = reject;\r\n            });\r\n            request.open('GET', url);\r\n            request.send();\r\n            return promise;\r\n        }\r\n\r\n        /**\r\n         * Recursively finds the slot elements in a given element.\r\n         * @param {HTMLElement} parent - the element which is searched for slots.\r\n         * @param {string} parentElName\r\n         * @param {object} result - a key:value object containing the slot elements\r\n         * under their data-name as value:\r\n         * { <my-slot-name>: HTMLElement }\r\n         * @returns {Object} result\r\n        */\r\n        findSlots(parent, parentElName, result = {}) {\r\n            const children = parent.children;\r\n            const length = children.length;\r\n\r\n            for (let i = 0; i < length; ++i) {\r\n                const child = children[i];\r\n                const childTagName = child.tagName.toLowerCase();\r\n\r\n                if (child instanceof ComponentSlot) {\r\n                    const name = child.dataset.name;\r\n                    if (!result[name]) result[name] = [];\r\n                    result[name].push(child);\r\n                    this.findSlots(child, parentElName, result);\r\n                } else if (child.hasAttribute('slot')) {\r\n                    const slot = child.getAttribute('slot');\r\n                    if (!result[slot]) result[slot] = [];\r\n                    result[slot].push(child);\r\n                    this.findSlots(child, parentElName, result);\r\n                    // the scrollable container is the ONLY component that can hold\r\n                    // slots of another elements; we allow this in order achieve\r\n                    // better integration of the scrollbar inside other components\r\n                    // The WebComponents and the standard slot elements don't support\r\n                    // such behavior; an element handles only its own slots. The scrollable\r\n                    // container is an exception from this rule.\r\n                } else if (childTagName === 'gameface-scrollable-container' ||\r\n                    (childTagName !== GF_COMPONENT_SLOT_TAG_NAME &&\r\n                        parentElName !== childTagName &&\r\n                        !this.definedElements[childTagName])) {\r\n                    // if the child is another nested element don't look for slots in it\r\n                    this.findSlots(child, parentElName, result);\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Will replace the slot element\r\n         * @param {HTMLElement[]} source\r\n         * @param {HTMLElement} target\r\n         */\r\n        replaceSlots(source, target) {\r\n            const fakeRoot = target[0];\r\n            if (source.length && fakeRoot.childNodes.length) {\r\n                while (fakeRoot.firstChild) {\r\n                    fakeRoot.removeChild(fakeRoot.lastChild);\r\n                }\r\n            }\r\n            // remove the slot so that it can be replaced\r\n            const parent = fakeRoot.parentNode;\r\n            parent.removeChild(fakeRoot);\r\n\r\n            for (let i = 0; i < source.length; ++i) {\r\n                parent.appendChild(source[i]);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Transfers the slottable elements into their slots.\r\n         * @param {HTMLElement} source - the element containing the slottable elements.\r\n         * @param {HTMLElement} target - the element containing the slots elements.\r\n        */\r\n        transferContent(source, target) {\r\n            while (target.childNodes.length > 0) {\r\n                const nodes = target.childNodes;\r\n                target.removeChild(nodes[nodes.length - 1]);\r\n            }\r\n            while (source.childNodes.length > 0) {\r\n                const nodes = source.childNodes;\r\n                const node = nodes[0];\r\n                source.removeChild(node);\r\n                target.appendChild(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Renderes an element only if it wasn't rendered before that\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean} - true if it was rendered, false if not\r\n        */\r\n        renderOnce(element) {\r\n            if (element.isRendered) return false;\r\n\r\n            this.render(element);\r\n            element.isRendered = true;\r\n            return true;\r\n        }\r\n\r\n        /**\r\n        * Renders an element's content into its template.\r\n        * @param {HTMLElement} element - the element into which to render the content\r\n        */\r\n        render(element) {\r\n            const templateRoot = document.createElement('div');\r\n            templateRoot.appendChild(element.template);\r\n\r\n            const parentElName = element.tagName.toLowerCase();\r\n\r\n            const templateSlots = this.findSlots(templateRoot, parentElName);\r\n            const userSlots = this.findSlots(element, parentElName);\r\n\r\n            // use for...of instead of for...in for better performance\r\n            const userSlotsKeys = Object.keys(userSlots);\r\n            const templateSlotsKeys = Object.keys(templateSlots);\r\n\r\n            // there's no point in looping over userSlots if there aren't\r\n            // corresponding template slots\r\n            if (templateSlotsKeys.length) {\r\n                for (const userSlot of userSlotsKeys) {\r\n                    if (!userSlots[userSlot] || !templateSlots[userSlot]) continue;\r\n                    this.replaceSlots(userSlots[userSlot], templateSlots[userSlot]);\r\n                }\r\n            }\r\n\r\n            this.transferContent(templateRoot, element);\r\n        }\r\n\r\n        /**\r\n         * Delay the execution of a callback function by n amount of frames.\r\n         * Used to retrieve the computed styles of elements.\r\n         * @param {Function} callback - the function that will be executed.\r\n         * @param {number} count - the amount of frames that the callback execution\r\n         * should be delayed by.\r\n         * @returns {any}\r\n        */\r\n        waitForFrames(callback = () => { }, count = 3) {\r\n            if (count === 0) return callback();\r\n            count--;\r\n            requestAnimationFrame(() => this.waitForFrames(callback, count));\r\n        }\r\n    }\r\n\r\n    const components = new GamefaceComponents();\r\n\r\n    /**\r\n     * Class used to import gameface components\r\n     */\r\n    class ComponentImport extends HTMLElement {\r\n        /* eslint-disable require-jsdoc */\r\n        constructor() {\r\n            super();\r\n        }\r\n\r\n        connectedCallback() {\r\n            const url = `/components/${this.dataset.url}/`;\r\n            const componentName = `gameface-${this.dataset.url}`;\r\n\r\n            if (components.imported.indexOf(componentName) === -1) {\r\n                components.importComponent(url);\r\n                components.imported.push(componentName);\r\n            }\r\n            this.appendChild(document.createElement(componentName));\r\n        }\r\n        /* eslint-enable require-jsdoc */\r\n    }\r\n\r\n    /**\r\n     * Class that will handle gameface components slot element\r\n     */\r\n    class ComponentSlot extends HTMLElement {\r\n        /* eslint-disable require-jsdoc */\r\n\r\n        constructor() {\r\n            super();\r\n\r\n            this.originalAppendChild = this.appendChild;\r\n            this.originalInsertBefore = this.insertBefore;\r\n            this.originalReplaceChild = this.replaceChild;\r\n            this.originalRemoveChild = this.removeChild;\r\n\r\n            this.appendChild = (node) => {\r\n                const child = this.originalAppendChild(node);\r\n                this.disptachSlotChange(child);\r\n\r\n                return child;\r\n            };\r\n\r\n            this.insertBefore = (newNode, referenceNode) => {\r\n                const child = this.originalInsertBefore(newNode, referenceNode);\r\n                this.disptachSlotChange(child);\r\n\r\n                return child;\r\n            };\r\n\r\n            this.replaceChild = (newChild, oldChild) => {\r\n                const replacedNode = this.originalReplaceChild(newChild, oldChild);\r\n                this.disptachSlotChange(replacedNode);\r\n\r\n                return replacedNode;\r\n            };\r\n\r\n            this.removeChild = (child) => {\r\n                const removedNode = this.originalRemoveChild(child);\r\n                this.disptachSlotChange(removedNode);\r\n\r\n                return removedNode;\r\n            };\r\n        }\r\n\r\n        disptachSlotChange(child) {\r\n            this.dispatchEvent(new CustomEvent('slotchange'), {\r\n                target: this,\r\n                child: child,\r\n            });\r\n        }\r\n\r\n        /* eslint-enable require-jsdoc */\r\n    }\r\n\r\n    components.defineCustomElement('component-import', ComponentImport);\r\n    components.defineCustomElement(GF_COMPONENT_SLOT_TAG_NAME, ComponentSlot);\r\n\r\n    return components;\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (components());\r\n\n\n//# sourceURL=webpack://gameuicomponents/./lib/components.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./components/modal/demo/demo.js");
/******/ 	
/******/ })()
;