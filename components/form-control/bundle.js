/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./components/form-control/demo/demo.js":
/*!**********************************************!*\
  !*** ./components/form-control/demo/demo.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _umd_form_control_development_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../umd/form-control.development.js */ \"./components/form-control/umd/form-control.development.js\");\n/* harmony import */ var _umd_form_control_development_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_umd_form_control_development_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var postmessage_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! postmessage-polyfill */ \"./components/form-control/node_modules/postmessage-polyfill/postmessage.js\");\n/* harmony import */ var postmessage_polyfill__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(postmessage_polyfill__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! whatwg-fetch */ \"./components/form-control/node_modules/whatwg-fetch/fetch.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Coherent Labs AD. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\n\n\n\nwindow.postMessage = function (message) {\n    (0,postmessage_polyfill__WEBPACK_IMPORTED_MODULE_1__.pm)({\n        origin: 'http://127.0.0.1/:3000',\n        target: window,\n        data: message\n    });\n};\n\n//# sourceURL=webpack://gameuicomponents/./components/form-control/demo/demo.js?");

/***/ }),

/***/ "./components/form-control/node_modules/postmessage-polyfill/postmessage.js":
/*!**********************************************************************************!*\
  !*** ./components/form-control/node_modules/postmessage-polyfill/postmessage.js ***!
  \**********************************************************************************/
/***/ (function() {

eval("/**\n The MIT License\n\n Copyright (c) 2010 Daniel Park (http://metaweb.com, http://postmessage.freebaseapps.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n **/\nvar NO_JQUERY = {};\n(function(window, $, undefined) {\n\n     if (!(\"console\" in window)) {\n         var c = window.console = {};\n         c.log = c.warn = c.error = c.debug = function(){};\n     }\n\n     if ($ === NO_JQUERY) {\n         // jQuery is optional\n         $ = {\n             fn: {},\n             extend: function() {\n                 var a = arguments[0];\n                 for (var i=1,len=arguments.length; i<len; i++) {\n                     var b = arguments[i];\n                     for (var prop in b) {\n                         a[prop] = b[prop];\n                     }\n                 }\n                 return a;\n             }\n         };\n     }\n\n     $.fn.pm = function() {\n         console.log(\"usage: \\nto send:    $.pm(options)\\nto receive: $.pm.bind(type, fn, [origin])\");\n         return this;\n     };\n\n     // send postmessage\n     $.pm = window.pm = function(options) {\n         pm.send(options);\n     };\n\n     // bind postmessage handler\n     $.pm.bind = window.pm.bind = function(type, fn, origin, hash, async_reply) {\n         pm.bind(type, fn, origin, hash, async_reply === true);\n     };\n\n     // unbind postmessage handler\n     $.pm.unbind = window.pm.unbind = function(type, fn) {\n         pm.unbind(type, fn);\n     };\n\n     // default postmessage origin on bind\n     $.pm.origin = window.pm.origin = null;\n\n     // default postmessage polling if using location hash to pass postmessages\n     $.pm.poll = window.pm.poll = 200;\n\n     var pm = {\n\n         send: function(options) {\n             var o = $.extend({}, pm.defaults, options),\n             target = o.target;\n             if (!o.target) {\n                 console.warn(\"postmessage target window required\");\n                 return;\n             }\n             if (!o.type) {\n                 console.warn(\"postmessage type required\");\n                 return;\n             }\n             var msg = {data:o.data, type:o.type};\n             if (o.success) {\n                 msg.callback = pm._callback(o.success);\n             }\n             if (o.error) {\n                 msg.errback = pm._callback(o.error);\n             }\n             if ((\"postMessage\" in target) && !o.hash) {\n                 pm._bind();\n                 target.postMessage(JSON.stringify(msg), o.origin || '*');\n             }\n             else {\n                 pm.hash._bind();\n                 pm.hash.send(o, msg);\n             }\n         },\n\n         bind: function(type, fn, origin, hash, async_reply) {\n           pm._replyBind ( type, fn, origin, hash, async_reply );\n         },\n       \n         _replyBind: function(type, fn, origin, hash, isCallback) {\n           if ((\"postMessage\" in window) && !hash) {\n               pm._bind();\n           }\n           else {\n               pm.hash._bind();\n           }\n           var l = pm.data(\"listeners.postmessage\");\n           if (!l) {\n               l = {};\n               pm.data(\"listeners.postmessage\", l);\n           }\n           var fns = l[type];\n           if (!fns) {\n               fns = [];\n               l[type] = fns;\n           }\n           fns.push({fn:fn, callback: isCallback, origin:origin || $.pm.origin});\n         },\n\n         unbind: function(type, fn) {\n             var l = pm.data(\"listeners.postmessage\");\n             if (l) {\n                 if (type) {\n                     if (fn) {\n                         // remove specific listener\n                         var fns = l[type];\n                         if (fns) {\n                             var m = [];\n                             for (var i=0,len=fns.length; i<len; i++) {\n                                 var o = fns[i];\n                                 if (o.fn !== fn) {\n                                     m.push(o);\n                                 }\n                             }\n                             l[type] = m;\n                         }\n                     }\n                     else {\n                         // remove all listeners by type\n                         delete l[type];\n                     }\n                 }\n                 else {\n                     // unbind all listeners of all type\n                     for (var i in l) {\n                       delete l[i];\n                     }\n                 }\n             }\n         },\n\n         data: function(k, v) {\n             if (v === undefined) {\n                 return pm._data[k];\n             }\n             pm._data[k] = v;\n             return v;\n         },\n\n         _data: {},\n\n         _CHARS: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\n\n         _random: function() {\n             var r = [];\n             for (var i=0; i<32; i++) {\n                 r[i] = pm._CHARS[0 | Math.random() * 32];\n             };\n             return r.join(\"\");\n         },\n\n         _callback: function(fn) {\n             var cbs = pm.data(\"callbacks.postmessage\");\n             if (!cbs) {\n                 cbs = {};\n                 pm.data(\"callbacks.postmessage\", cbs);\n             }\n             var r = pm._random();\n             cbs[r] = fn;\n             return r;\n         },\n\n         _bind: function() {\n             // are we already listening to message events on this w?\n             if (!pm.data(\"listening.postmessage\")) {\n                 if (window.addEventListener) {\n                     window.addEventListener(\"message\", pm._dispatch, false);\n                 }\n                 else if (window.attachEvent) {\n                     window.attachEvent(\"onmessage\", pm._dispatch);\n                 }\n                 pm.data(\"listening.postmessage\", 1);\n             }\n         },\n\n         _dispatch: function(e) {\n             //console.log(\"$.pm.dispatch\", e, this);\n             try {\n                 var msg = JSON.parse(e.data);\n             }\n             catch (ex) {\n                 console.warn(\"postmessage data invalid json: \", ex);\n                 return;\n             }\n             if (!msg.type) {\n                 console.warn(\"postmessage message type required\");\n                 return;\n             }\n             var cbs = pm.data(\"callbacks.postmessage\") || {},\n             cb = cbs[msg.type];\n             if (cb) {\n                 cb(msg.data);\n             }\n             else {\n                 var l = pm.data(\"listeners.postmessage\") || {};\n                 var fns = l[msg.type] || [];\n                 for (var i=0,len=fns.length; i<len; i++) {\n                     var o = fns[i];\n                     if (o.origin && o.origin !== '*' && e.origin !== o.origin) {\n                         console.warn(\"postmessage message origin mismatch\", e.origin, o.origin);\n                         if (msg.errback) {\n                             // notify post message errback\n                             var error = {\n                                 message: \"postmessage origin mismatch\",\n                                 origin: [e.origin, o.origin]\n                             };\n                             pm.send({target:e.source, data:error, type:msg.errback});\n                         }\n                         continue;\n                     }\n\n                     function sendReply ( data ) {\n                       if (msg.callback) {\n                           pm.send({target:e.source, data:data, type:msg.callback});\n                       }\n                     }\n                     \n                     try {\n                         if ( o.callback ) {\n                           o.fn(msg.data, sendReply, e);\n                         } else {\n                           sendReply ( o.fn(msg.data, e) );\n                         }\n                     }\n                     catch (ex) {\n                         if (msg.errback) {\n                             // notify post message errback\n                             pm.send({target:e.source, data:ex, type:msg.errback});\n                         } else {\n                             throw ex;\n                         }\n                     }\n                 };\n             }\n         }\n     };\n\n     // location hash polling\n     pm.hash = {\n\n         send: function(options, msg) {\n             //console.log(\"hash.send\", target_window, options, msg);\n             var target_window = options.target,\n             target_url = options.url;\n             if (!target_url) {\n                 console.warn(\"postmessage target window url is required\");\n                 return;\n             }\n             target_url = pm.hash._url(target_url);\n             var source_window,\n             source_url = pm.hash._url(window.location.href);\n             if (window == target_window.parent) {\n                 source_window = \"parent\";\n             }\n             else {\n                 try {\n                     for (var i=0,len=parent.frames.length; i<len; i++) {\n                         var f = parent.frames[i];\n                         if (f == window) {\n                             source_window = i;\n                             break;\n                         }\n                     };\n                 }\n                 catch(ex) {\n                     // Opera: security error trying to access parent.frames x-origin\n                     // juse use window.name\n                     source_window = window.name;\n                 }\n             }\n             if (source_window == null) {\n                 console.warn(\"postmessage windows must be direct parent/child windows and the child must be available through the parent window.frames list\");\n                 return;\n             }\n             var hashmessage = {\n                 \"x-requested-with\": \"postmessage\",\n                 source: {\n                     name: source_window,\n                     url: source_url\n                 },\n                 postmessage: msg\n             };\n             var hash_id = \"#x-postmessage-id=\" + pm._random();\n             target_window.location = target_url + hash_id + encodeURIComponent(JSON.stringify(hashmessage));\n         },\n\n         _regex: /^\\#x\\-postmessage\\-id\\=(\\w{32})/,\n\n         _regex_len: \"#x-postmessage-id=\".length + 32,\n\n         _bind: function() {\n             // are we already listening to message events on this w?\n             if (!pm.data(\"polling.postmessage\")) {\n                 setInterval(function() {\n                                 var hash = \"\" + window.location.hash,\n                                 m = pm.hash._regex.exec(hash);\n                                 if (m) {\n                                     var id = m[1];\n                                     if (pm.hash._last !== id) {\n                                         pm.hash._last = id;\n                                         pm.hash._dispatch(hash.substring(pm.hash._regex_len));\n                                     }\n                                 }\n                             }, $.pm.poll || 200);\n                 pm.data(\"polling.postmessage\", 1);\n             }\n         },\n\n         _dispatch: function(hash) {\n             if (!hash) {\n                 return;\n             }\n             try {\n                 hash = JSON.parse(decodeURIComponent(hash));\n                 if (!(hash['x-requested-with'] === 'postmessage' &&\n                       hash.source && hash.source.name != null && hash.source.url && hash.postmessage)) {\n                     // ignore since hash could've come from somewhere else\n                     return;\n                 }\n             }\n             catch (ex) {\n                 // ignore since hash could've come from somewhere else\n                 return;\n             }\n             var msg = hash.postmessage,\n             cbs = pm.data(\"callbacks.postmessage\") || {},\n             cb = cbs[msg.type];\n             if (cb) {\n                 cb(msg.data);\n             }\n             else {\n                 var source_window;\n                 if (hash.source.name === \"parent\") {\n                     source_window = window.parent;\n                 }\n                 else {\n                     source_window = window.frames[hash.source.name];\n                 }\n                 var l = pm.data(\"listeners.postmessage\") || {};\n                 var fns = l[msg.type] || [];\n                 for (var i=0,len=fns.length; i<len; i++) {\n                     var o = fns[i];\n                     if (o.origin) {\n                         var origin = /https?\\:\\/\\/[^\\/]*/.exec(hash.source.url)[0];\n                         if (o.origin !== '*' && origin !== o.origin) {\n                             console.warn(\"postmessage message origin mismatch\", origin, o.origin);\n                             if (msg.errback) {\n                                 // notify post message errback\n                                 var error = {\n                                     message: \"postmessage origin mismatch\",\n                                     origin: [origin, o.origin]\n                                 };\n                                 pm.send({target:source_window, data:error, type:msg.errback, hash:true, url:hash.source.url});\n                             }\n                             continue;\n                         }\n                     }\n\n                     function sendReply ( data ) {\n                       if (msg.callback) {\n                         pm.send({target:source_window, data:data, type:msg.callback, hash:true, url:hash.source.url});\n                       }\n                     }\n                     \n                     try {\n                         if ( o.callback ) {\n                           o.fn(msg.data, sendReply);\n                         } else {\n                           sendReply ( o.fn(msg.data) );\n                         }\n                     }\n                     catch (ex) {\n                         if (msg.errback) {\n                             // notify post message errback\n                             pm.send({target:source_window, data:ex, type:msg.errback, hash:true, url:hash.source.url});\n                         } else {\n                             throw ex;\n                         }\n                     }\n                 };\n             }\n         },\n\n         _url: function(url) {\n             // url minus hash part\n             return (\"\"+url).replace(/#.*$/, \"\");\n         }\n\n     };\n\n     $.extend(pm, {\n                  defaults: {\n                      target: null,  /* target window (required) */\n                      url: null,     /* target window url (required if no window.postMessage or hash == true) */\n                      type: null,    /* message type (required) */\n                      data: null,    /* message data (required) */\n                      success: null, /* success callback (optional) */\n                      error: null,   /* error callback (optional) */\n                      origin: \"*\",   /* postmessage origin (optional) */\n                      hash: false    /* use location hash for message passing (optional) */\n                  }\n              });\n\n })(this, typeof jQuery === \"undefined\" ? NO_JQUERY : jQuery);\n\n/**\n * http://www.JSON.org/json2.js\n **/\nif (! (\"JSON\" in window && window.JSON)){JSON={}}(function(){function f(n){return n<10?\"0\"+n:n}if(typeof Date.prototype.toJSON!==\"function\"){Date.prototype.toJSON=function(key){return this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\"};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf()}}var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;function quote(string){escapable.lastIndex=0;return escapable.test(string)?'\"'+string.replace(escapable,function(a){var c=meta[a];return typeof c===\"string\"?c:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+string+'\"'}function str(key,holder){var i,k,v,length,mind=gap,partial,value=holder[key];if(value&&typeof value===\"object\"&&typeof value.toJSON===\"function\"){value=value.toJSON(key)}if(typeof rep===\"function\"){value=rep.call(holder,key,value)}switch(typeof value){case\"string\":return quote(value);case\"number\":return isFinite(value)?String(value):\"null\";case\"boolean\":case\"null\":return String(value);case\"object\":if(!value){return\"null\"}gap+=indent;partial=[];if(Object.prototype.toString.apply(value)===\"[object Array]\"){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||\"null\"}v=partial.length===0?\"[]\":gap?\"[\\n\"+gap+partial.join(\",\\n\"+gap)+\"\\n\"+mind+\"]\":\"[\"+partial.join(\",\")+\"]\";gap=mind;return v}if(rep&&typeof rep===\"object\"){length=rep.length;for(i=0;i<length;i+=1){k=rep[i];if(typeof k===\"string\"){v=str(k,value);if(v){partial.push(quote(k)+(gap?\": \":\":\")+v)}}}}else{for(k in value){if(Object.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?\": \":\":\")+v)}}}}v=partial.length===0?\"{}\":gap?\"{\\n\"+gap+partial.join(\",\\n\"+gap)+\"\\n\"+mind+\"}\":\"{\"+partial.join(\",\")+\"}\";gap=mind;return v}}if(typeof JSON.stringify!==\"function\"){JSON.stringify=function(value,replacer,space){var i;gap=\"\";indent=\"\";if(typeof space===\"number\"){for(i=0;i<space;i+=1){indent+=\" \"}}else{if(typeof space===\"string\"){indent=space}}rep=replacer;if(replacer&&typeof replacer!==\"function\"&&(typeof replacer!==\"object\"||typeof replacer.length!==\"number\")){throw new Error(\"JSON.stringify\")}return str(\"\",{\"\":value})}}if(typeof JSON.parse!==\"function\"){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value===\"object\"){for(k in value){if(Object.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v}else{delete value[k]}}}}return reviver.call(holder,key,value)}cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})}if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver===\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")}}}());\n\n\n//# sourceURL=webpack://gameuicomponents/./components/form-control/node_modules/postmessage-polyfill/postmessage.js?");

/***/ }),

/***/ "./components/form-control/node_modules/whatwg-fetch/fetch.js":
/*!********************************************************************!*\
  !*** ./components/form-control/node_modules/whatwg-fetch/fetch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Headers\": () => (/* binding */ Headers),\n/* harmony export */   \"Request\": () => (/* binding */ Request),\n/* harmony export */   \"Response\": () => (/* binding */ Response),\n/* harmony export */   \"DOMException\": () => (/* binding */ DOMException),\n/* harmony export */   \"fetch\": () => (/* binding */ fetch)\n/* harmony export */ });\nvar global =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  (typeof global !== 'undefined' && global)\n\nvar support = {\n  searchParams: 'URLSearchParams' in global,\n  iterable: 'Symbol' in global && 'iterator' in Symbol,\n  blob:\n    'FileReader' in global &&\n    'Blob' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in global,\n  arrayBuffer: 'ArrayBuffer' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : ''\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get('Content-Type') &&\n        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n\n\n//# sourceURL=webpack://gameuicomponents/./components/form-control/node_modules/whatwg-fetch/fetch.js?");

/***/ }),

/***/ "./components/form-control/umd/form-control.development.js":
/*!*****************************************************************!*\
  !*** ./components/form-control/umd/form-control.development.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? module.exports = factory(__webpack_require__(/*! coherent-gameface-components */ \"./lib/components.js\")) :\n    0;\n})(this, (function (components) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var components__default = /*#__PURE__*/_interopDefaultLegacy(components);\n\n    var template = \"<!--Copyright (c) Coherent Labs AD. All rights reserved. Licensed under the MIT License. See License.txt in the project root for license information. -->\\r\\n<div class=\\\"tooltip\\\">\\r\\n    <component-slot data-name=\\\"message\\\"></component-slot>\\r\\n</div>\\r\\n\";\n\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Coherent Labs AD. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    const TOOLTIP_MARGIN = 5;\r\n    const TOOLTIP_POSITIONS = ['top', 'bottom', 'left', 'right'];\r\n\r\n    class Tooltip extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n            this.template = template;\r\n            this.visible = false;\r\n            this._targetElement;\r\n\r\n            this.uncheckedOrientations = TOOLTIP_POSITIONS;\r\n        }\r\n\r\n        set targetElement(element) {\r\n            this._targetElement = element;\r\n        }\r\n\r\n        get targetElement() {\r\n            return this._targetElement;\r\n        }\r\n\r\n        get overflows() {\r\n            var rect = this.getBoundingClientRect();\r\n            const overflows = {};\r\n\r\n            if (rect.top < 0) overflows.top = true;\r\n            if (rect.left < 0)  overflows.left = true;\r\n            if (rect.right > (window.innerWidth || document.documentElement.clientWidth)) overflows.right = true;\r\n            if (rect.bottom > (window.innerHeight || document.documentElement.clientHeight)) overflows.bottom = true;\r\n\r\n            return overflows;\r\n        }\r\n\r\n        connectedCallback() {\r\n            this.position = this.getAttribute('position') || 'top';\r\n            this.showOn = this.getAttribute('on');\r\n            this.hideOn = this.getAttribute('off');\r\n            this.elementSelector = this.getAttribute('target');\r\n\r\n            this.triggerElement = this.targetElement || document.querySelector(this.elementSelector);\r\n            if (!this.triggerElement) {\r\n                console.error(`An element with selector ${this.elementSelector} does not exit. Please make sure the selector is correct and the element exists.`);\r\n                return;\r\n            }\r\n\r\n            components__default[\"default\"].loadResource(this)\r\n                .then((result) => {\r\n                    this.template = result.template;\r\n                    components__default[\"default\"].renderOnce(this);\r\n                    this.attachEventListeners();\r\n                })\r\n                .catch(err => console.error(err));\r\n        }\r\n\r\n        attachEventListeners() {\r\n            if (this.showOn === this.hideOn) {\r\n                this.triggerElement.addEventListener(this.showOn, () => this.toggle());\r\n                return;\r\n            }\r\n\r\n            this.triggerElement.addEventListener(this.showOn, () => this.show());\r\n            this.triggerElement.addEventListener(this.hideOn, () => this.hide());\r\n        }\r\n\r\n        toggle() {\r\n            this.visible ? this.hide() : this.show();\r\n        }\r\n\r\n        hide () {\r\n            this.style.display = 'none';\r\n            this.visible = false;\r\n            // reset the current positioning as the page might get\r\n            // resized untill the next time the tooltip is displayed\r\n            this.uncheckedOrientations = TOOLTIP_POSITIONS;\r\n            this.position = this.getAttribute('position') || 'top';\r\n        }\r\n\r\n        async show() {\r\n            // use visibility before showing to calculate the size\r\n            this.style.visibility = 'hidden';\r\n            this.style.display = '';\r\n\r\n            await this.setPosition(window.scrollX, window.scrollY);\r\n\r\n            this.style.visibility = 'visible';\r\n            this.visible = true;\r\n            this.classList.add('tooltip-show-animation');\r\n        }\r\n\r\n        /**\r\n         * Calculates the new position of the tooltip based on the given orientation.\r\n         * @param {string} orientation - top, left, right or bottom.\r\n         * @param {object} elementSize - the bounding rect of the element that triggered the tooltip show.\r\n         * @returns {Array<string|object>} - the orientation as a string and the position as an object in an array so that we can\r\n         * easily deconstruct the value like this: let [orientation, position] = getPositionCoords(...).\r\n        */\r\n        getPositionCoords(orientation, elementSize) {\r\n            const tooltipSize = this.getBoundingClientRect();\r\n\r\n            let elementPosition = {\r\n                top: (elementSize.top + elementSize.height / 2) - tooltipSize.height / 2,\r\n                left: elementSize.left + (elementSize.width / 2) - tooltipSize.width / 2\r\n            };\r\n\r\n            switch (orientation) {\r\n                case 'top':\r\n                    elementPosition.top = elementSize.top - TOOLTIP_MARGIN - tooltipSize.height;\r\n                    break;\r\n                case 'bottom':\r\n                    elementPosition.top = elementSize.top + elementSize.height + TOOLTIP_MARGIN;\r\n                    break;\r\n                case 'left':\r\n                    elementPosition.left = elementSize.left - tooltipSize.width - TOOLTIP_MARGIN;\r\n                    break;\r\n                case 'right':\r\n                    elementPosition.left = elementSize.left + elementSize.width + TOOLTIP_MARGIN;\r\n                    break;\r\n                default:\r\n                    elementPosition.top = elementSize.top - TOOLTIP_MARGIN - tooltipSize.height;\r\n                    console.log(`The provided option for position ${orientation} is not valid - using top as a fallback. Possible options are top, bottom, left and right.`);\r\n                    orientation = 'top';\r\n                    break;\r\n            }\r\n\r\n            return [orientation, elementPosition];\r\n        }\r\n\r\n        /**\r\n         * Sets the new position of the tooltip. Waits 2 frames for the tooltip to be fully rendered\r\n         * and checks if the tooltip is visible on the new position. If it is not - calls setPosition\r\n         * recursively until a suitable position is found or we've ran out of possibilities.\r\n         * @param {number} scrollOffsetX - the offset of the scroll on the X axis.\r\n         * @param {number} scrollOffsetY - the offset of the scroll on the Y axis.\r\n         * @param {string} orientation - the current position of the tooltip - top, left, right or bottom.\r\n         * @returns {promise}\r\n        */\r\n        async setPosition(scrollOffsetX, scrollOffsetY, orientation = this.position) {\r\n            const elementSize = this.triggerElement.getBoundingClientRect();\r\n\r\n            let [updatedOrientation, elementPosition] = this.getPositionCoords(orientation, elementSize);\r\n\r\n            this.position = updatedOrientation;\r\n            this.style.top = scrollOffsetY + elementPosition.top + 'px';\r\n            this.style.left = scrollOffsetX + elementPosition.left + 'px';\r\n\r\n            await this.waitForFrames(2);\r\n            let overflowingSides = Object.keys(this.overflows);\r\n            if (overflowingSides.length && this.uncheckedOrientations.length !== 0) {\r\n                return await this.setPosition(scrollOffsetX, scrollOffsetY, this.getVisiblePosition(overflowingSides));\r\n            }\r\n        }\r\n\r\n        /**\r\n         * An asynchronous method that waits for given amount of frames before it resolves;\r\n         * useful in cases where we need to wait for styles to be computed.\r\n         * @param {number} count - the number of frames it should wait for before resolving.\r\n         * @returns {promise}\r\n         */\r\n        async waitForFrames(count) {\r\n            while(count--) {\r\n                await new Promise((resolve) => requestAnimationFrame(resolve));\r\n            }\r\n        }\r\n\r\n\r\n\r\n        /**\r\n         * Gets the next value of a list of possible positions for the tooltip.\r\n         * The possible positions is the difference between the overflowing positions and the\r\n         * positions that haven't been tried yet.\r\n         * @param {Array<string>} overflowingSides - an array of the sides of which the tooltip is hidden.\r\n         * @returns {string} position - the new position.\r\n         */\r\n        getVisiblePosition(overflowingSides) {\r\n            this.uncheckedOrientations = this.uncheckedOrientations.filter(side => !overflowingSides.includes(side));\r\n            // the new position is the first element if the uncheckedOrientations array\r\n            // return the first element and remove it from the array because it is now\r\n            // part of the \"checked\" positions\r\n            return this.uncheckedOrientations.shift();\r\n        }\r\n    }\r\n\r\n    components__default[\"default\"].defineCustomElement('gameface-tooltip', Tooltip);\n\n    var errorMessages = new Map([\r\n        ['notAForm', () => 'This element is not part of a form.'],\r\n        ['tooLong', (element) => `The value is too long. Maximum length is ${element.getAttribute('maxlength')}.`],\r\n        ['tooShort', (element) => `The value is too short. Minimal length is ${element.getAttribute('minlength')}.`],\r\n        ['rangeOverflow', (element) => `The value is too big. Maximum is ${element.getAttribute('max')}.`],\r\n        ['rangeUnderflow', (element) => `The value is too small. Minimum is ${element.getAttribute('min')}.`],\r\n        ['valueMissing', () => 'The value is required.'],\r\n        ['nameMissing', () => 'The elements does not have a name attribute and will not be submitted'],\r\n        ['badURL', (element) => `Please enter a valid URL. It should match the following pattern: /${element.pattern || element.getAttribute('pattern')}/.`],\r\n        ['badEmail', () => `Please enter a valid email. It should contain a @ symbol.`],\r\n        ['customError', (error) => `The following error has ocurred: ${error}.`],\r\n    ]);\n\n    /**\n     *\n     *\n     * @author Jerry Bendy <jerry@icewingcc.com>\n     * @licence MIT\n     *\n     */\n\n    (function(self) {\n\n        var nativeURLSearchParams = (function() {\n                // #41 Fix issue in RN\n                try {\n                    if (self.URLSearchParams && (new self.URLSearchParams('foo=bar')).get('foo') === 'bar') {\n                        return self.URLSearchParams;\n                    }\n                } catch (e) {}\n                return null;\n            })(),\n            isSupportObjectConstructor = nativeURLSearchParams && (new nativeURLSearchParams({a: 1})).toString() === 'a=1',\n            // There is a bug in safari 10.1 (and earlier) that incorrectly decodes `%2B` as an empty space and not a plus.\n            decodesPlusesCorrectly = nativeURLSearchParams && (new nativeURLSearchParams('s=%2B').get('s') === '+'),\n            __URLSearchParams__ = \"__URLSearchParams__\",\n            // Fix bug in Edge which cannot encode ' &' correctly\n            encodesAmpersandsCorrectly = nativeURLSearchParams ? (function() {\n                var ampersandTest = new nativeURLSearchParams();\n                ampersandTest.append('s', ' &');\n                return ampersandTest.toString() === 's=+%26';\n            })() : true,\n            prototype = URLSearchParamsPolyfill.prototype,\n            iterable = !!(self.Symbol && self.Symbol.iterator);\n\n        if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {\n            return;\n        }\n\n\n        /**\n         * Make a URLSearchParams instance\n         *\n         * @param {object|string|URLSearchParams} search\n         * @constructor\n         */\n        function URLSearchParamsPolyfill(search) {\n            search = search || \"\";\n\n            // support construct object with another URLSearchParams instance\n            if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {\n                search = search.toString();\n            }\n            this [__URLSearchParams__] = parseToDict(search);\n        }\n\n\n        /**\n         * Appends a specified key/value pair as a new search parameter.\n         *\n         * @param {string} name\n         * @param {string} value\n         */\n        prototype.append = function(name, value) {\n            appendTo(this [__URLSearchParams__], name, value);\n        };\n\n        /**\n         * Deletes the given search parameter, and its associated value,\n         * from the list of all search parameters.\n         *\n         * @param {string} name\n         */\n        prototype['delete'] = function(name) {\n            delete this [__URLSearchParams__] [name];\n        };\n\n        /**\n         * Returns the first value associated to the given search parameter.\n         *\n         * @param {string} name\n         * @returns {string|null}\n         */\n        prototype.get = function(name) {\n            var dict = this [__URLSearchParams__];\n            return this.has(name) ? dict[name][0] : null;\n        };\n\n        /**\n         * Returns all the values association with a given search parameter.\n         *\n         * @param {string} name\n         * @returns {Array}\n         */\n        prototype.getAll = function(name) {\n            var dict = this [__URLSearchParams__];\n            return this.has(name) ? dict [name].slice(0) : [];\n        };\n\n        /**\n         * Returns a Boolean indicating if such a search parameter exists.\n         *\n         * @param {string} name\n         * @returns {boolean}\n         */\n        prototype.has = function(name) {\n            return hasOwnProperty(this [__URLSearchParams__], name);\n        };\n\n        /**\n         * Sets the value associated to a given search parameter to\n         * the given value. If there were several values, delete the\n         * others.\n         *\n         * @param {string} name\n         * @param {string} value\n         */\n        prototype.set = function set(name, value) {\n            this [__URLSearchParams__][name] = ['' + value];\n        };\n\n        /**\n         * Returns a string containg a query string suitable for use in a URL.\n         *\n         * @returns {string}\n         */\n        prototype.toString = function() {\n            var dict = this[__URLSearchParams__], query = [], i, key, name, value;\n            for (key in dict) {\n                name = encode(key);\n                for (i = 0, value = dict[key]; i < value.length; i++) {\n                    query.push(name + '=' + encode(value[i]));\n                }\n            }\n            return query.join('&');\n        };\n\n        // There is a bug in Safari 10.1 and `Proxy`ing it is not enough.\n        var forSureUsePolyfill = !decodesPlusesCorrectly;\n        var useProxy = (!forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self.Proxy);\n        var propValue; \n        if (useProxy) {\n            // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0\n            propValue = new Proxy(nativeURLSearchParams, {\n                construct: function (target, args) {\n                    return new target((new URLSearchParamsPolyfill(args[0]).toString()));\n                }\n            });\n            // Chrome <=60 .toString() on a function proxy got error \"Function.prototype.toString is not generic\"\n            propValue.toString = Function.prototype.toString.bind(URLSearchParamsPolyfill);\n        } else {\n            propValue = URLSearchParamsPolyfill;\n        }\n        /*\n         * Apply polifill to global object and append other prototype into it\n         */\n        Object.defineProperty(self, 'URLSearchParams', {\n            value: propValue\n        });\n\n        var USPProto = self.URLSearchParams.prototype;\n\n        USPProto.polyfill = true;\n\n        /**\n         *\n         * @param {function} callback\n         * @param {object} thisArg\n         */\n        USPProto.forEach = USPProto.forEach || function(callback, thisArg) {\n            var dict = parseToDict(this.toString());\n            Object.getOwnPropertyNames(dict).forEach(function(name) {\n                dict[name].forEach(function(value) {\n                    callback.call(thisArg, value, name, this);\n                }, this);\n            }, this);\n        };\n\n        /**\n         * Sort all name-value pairs\n         */\n        USPProto.sort = USPProto.sort || function() {\n            var dict = parseToDict(this.toString()), keys = [], k, i, j;\n            for (k in dict) {\n                keys.push(k);\n            }\n            keys.sort();\n\n            for (i = 0; i < keys.length; i++) {\n                this['delete'](keys[i]);\n            }\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i], values = dict[key];\n                for (j = 0; j < values.length; j++) {\n                    this.append(key, values[j]);\n                }\n            }\n        };\n\n        /**\n         * Returns an iterator allowing to go through all keys of\n         * the key/value pairs contained in this object.\n         *\n         * @returns {function}\n         */\n        USPProto.keys = USPProto.keys || function() {\n            var items = [];\n            this.forEach(function(item, name) {\n                items.push(name);\n            });\n            return makeIterator(items);\n        };\n\n        /**\n         * Returns an iterator allowing to go through all values of\n         * the key/value pairs contained in this object.\n         *\n         * @returns {function}\n         */\n        USPProto.values = USPProto.values || function() {\n            var items = [];\n            this.forEach(function(item) {\n                items.push(item);\n            });\n            return makeIterator(items);\n        };\n\n        /**\n         * Returns an iterator allowing to go through all key/value\n         * pairs contained in this object.\n         *\n         * @returns {function}\n         */\n        USPProto.entries = USPProto.entries || function() {\n            var items = [];\n            this.forEach(function(item, name) {\n                items.push([name, item]);\n            });\n            return makeIterator(items);\n        };\n\n\n        if (iterable) {\n            USPProto[self.Symbol.iterator] = USPProto[self.Symbol.iterator] || USPProto.entries;\n        }\n\n\n        function encode(str) {\n            var replace = {\n                '!': '%21',\n                \"'\": '%27',\n                '(': '%28',\n                ')': '%29',\n                '~': '%7E',\n                '%20': '+',\n                '%00': '\\x00'\n            };\n            return encodeURIComponent(str).replace(/[!'\\(\\)~]|%20|%00/g, function(match) {\n                return replace[match];\n            });\n        }\n\n        function decode(str) {\n            return str\n                .replace(/[ +]/g, '%20')\n                .replace(/(%[a-f0-9]{2})+/ig, function(match) {\n                    return decodeURIComponent(match);\n                });\n        }\n\n        function makeIterator(arr) {\n            var iterator = {\n                next: function() {\n                    var value = arr.shift();\n                    return {done: value === undefined, value: value};\n                }\n            };\n\n            if (iterable) {\n                iterator[self.Symbol.iterator] = function() {\n                    return iterator;\n                };\n            }\n\n            return iterator;\n        }\n\n        function parseToDict(search) {\n            var dict = {};\n\n            if (typeof search === \"object\") {\n                // if `search` is an array, treat it as a sequence\n                if (isArray(search)) {\n                    for (var i = 0; i < search.length; i++) {\n                        var item = search[i];\n                        if (isArray(item) && item.length === 2) {\n                            appendTo(dict, item[0], item[1]);\n                        } else {\n                            throw new TypeError(\"Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements\");\n                        }\n                    }\n\n                } else {\n                    for (var key in search) {\n                        if (search.hasOwnProperty(key)) {\n                            appendTo(dict, key, search[key]);\n                        }\n                    }\n                }\n\n            } else {\n                // remove first '?'\n                if (search.indexOf(\"?\") === 0) {\n                    search = search.slice(1);\n                }\n\n                var pairs = search.split(\"&\");\n                for (var j = 0; j < pairs.length; j++) {\n                    var value = pairs [j],\n                        index = value.indexOf('=');\n\n                    if (-1 < index) {\n                        appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));\n\n                    } else {\n                        if (value) {\n                            appendTo(dict, decode(value), '');\n                        }\n                    }\n                }\n            }\n\n            return dict;\n        }\n\n        function appendTo(dict, name, value) {\n            var val = typeof value === 'string' ? value : (\n                value !== null && value !== undefined && typeof value.toString === 'function' ? value.toString() : JSON.stringify(value)\n            );\n\n            // #47 Prevent using `hasOwnProperty` as a property name\n            if (hasOwnProperty(dict, name)) {\n                dict[name].push(val);\n            } else {\n                dict[name] = [val];\n            }\n        }\n\n        function isArray(val) {\n            return !!val && '[object Array]' === Object.prototype.toString.call(val);\n        }\n\n        function hasOwnProperty(obj, prop) {\n            return Object.prototype.hasOwnProperty.call(obj, prop);\n        }\n\n    })(typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : (typeof window !== 'undefined' ? window : undefined));\n\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Coherent Labs AD. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n\n    const formMethods = {\n        GET: 'GET',\n        POST: 'POST'\n    };\n\n    const tags = {\n        BUTTON: 'button',\n        INPUT: 'input',\n        TEXTAREA: 'textarea',\n        GAMEFACE_CHECKBOX: 'gameface-checkbox',\n        GAMEFACE_DROPDOWN: 'gameface-dropdown',\n        GAMEFACE_RADIO_GROUP: 'gameface-radio-group',\n        GAMEFACE_RANGESLIDER: 'gameface-rangeslider',\n        GAMEFACE_SWITCH: 'gameface-switch',\n        TEXT_FIELD: 'gameface-text-field',\n        //polyfill elements\n        SELECT: 'custom-select',\n    };\n\n    const VALID_SUBMIT_ELEMENT_TAGS = new Set([tags.BUTTON, tags.INPUT]);\n    const VALID_FORM_CONTROL_ELEMENT_TAGS = new Set([tags.BUTTON, tags.INPUT, tags.TEXTAREA, tags.SELECT]);\n    const VALID_FORM_CONTROL_CUSTOM_ELEMENT_TAGS = new Set([\n        tags.GAMEFACE_CHECKBOX,\n        tags.GAMEFACE_DROPDOWN,\n        tags.GAMEFACE_RADIO_GROUP,\n        tags.GAMEFACE_RANGESLIDER,\n        tags.GAMEFACE_SWITCH,\n        tags.TEXT_FIELD\n    ]);\n\n    const NativeElementValidator = components__default[\"default\"].NativeElementValidator;\n    const CustomElementValidator = components__default[\"default\"].CustomElementValidator;\n\n    /**\n    * @callback ValidationMethod\n    * @param {HTMLElement} [element]\n    * @return {boolean}\n    */\n\n    /**\n     * @callback ErrorMessageMethod\n     * @param {HTMLElement} [element]\n     * @return {string}\n     */\n\n    /**\n     * @typedef {Object} Validator\n     * @property {ValidationMethod} [method]\n     * @property {ErrorMessageMethod} [errorMessage]\n     */\n\n    /**\n     * @typedef {Object<string,Validator>} Validators\n     */\n\n    class GamefaceFormControl extends HTMLElement {\n        constructor() {\n            super();\n            /**\n             * @type {XMLHttpRequest}\n             */\n            this.xhr = new XMLHttpRequest();\n            /**\n             * @type {HTMLElement}\n             */\n            this.currentSubmitButton = null;\n            /**\n             * @type {Object<string,Validators>}\n             */\n            this.customValidators = {};\n            /**\n             * @type {Object<string,HTMLElement>}\n             */\n            this.errorDisplayElements = {};\n        }\n\n        get method() {\n            return this.getAttribute('method') || formMethods.GET;\n        }\n\n        get action() {\n            return this.getAttribute('action') || '';\n        }\n\n        get formElements() {\n            const elements = [];\n\n            this.traverseFormElements(this, (element, elements = []) => {\n                if (!this.isValidFormElement(element) || this.isElementUsedToSubmit(element)) return;\n                elements.push(element);\n            }, [elements]);\n\n            return elements;\n        }\n\n        /**\n         * Checks if an some function argument is valid. It will check if there is an argument value passed and if the argument type\n         * is the same as the expected passed with argType\n         * @param {string} argName - The name of the argument\n         * @param {string} argValue - The value of the argument\n         * @param {string} [argType] - The expected type of the argument\n         * @returns {boolean}\n         */\n        isArgumentValid(argName, argValue, argType = '') {\n            if (!argValue) {\n                console.warn(`The value of \"${argName}\" is \"${argValue}\". You must pass a valid \"${argName}\" that is of type \"${argType}\"`);\n                return false;\n            }\n\n            //if there is not argType passed we will skip the type check\n            if (argType && typeof argValue !== argType) {\n                console.warn(`The type of \"${argName}\" argument is not valid. Please make sure it is of type \"${argType}\".`);\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Will add an element where the errors about the form element with the passed name will be displayed\n         * @param {string} name - The name attribute value of a form element\n         * @param {string} selector - The selector of the element where the errors will be displayed\n         */\n        setCustomDisplayErrorElement(name, selector) {\n            if (!this.isArgumentValid('name', name, 'string') ||\n                !this.isArgumentValid('selector', selector, 'string')) return;\n\n            const element = document.querySelector(selector);\n            if (!element) {\n                console.log(`Unable to find element with \"${selector}\" selector! Please pass a valid element selector!`);\n                return;\n            }\n\n            this.errorDisplayElements[name] = element;\n        }\n\n        /**\n         * Method for removing element where the errors related to the form element with the passed name should be displayed\n         * @param {string} name - The name attribute value of a form element\n         */\n        removeCustomDisplayErrorElement(name) {\n            if (!this.isArgumentValid('name', name, 'string')) return;\n\n            delete this.errorDisplayElements[name];\n        }\n\n        /**\n         * Method for removing elements where the errors related to the form elements with the passed names should be displayed\n         * @param {Array<string>} names - Array with names related to the form elements\n         */\n        removeCustomDisplayErrorElements(names) {\n            if (!this.isArgumentValid('names', names) || !(names instanceof Array)) return;\n\n            for (const name of names) {\n                if (typeof name !== 'string') {\n                    console.warn(`Found a \"${name}\" insthe array with \"names\" that is not a string. Will ignore it!`);\n                    continue;\n                }\n\n                delete this.errorDisplayElements[name];\n            }\n        }\n\n        /**\n         * Will set user defined custom validators about form element with the passed name\n         * @param {string} name - The name attribute value of a form element \n         * @param {Validators} validators - Custom validators configuration\n         */\n        setCustomValidators(name, validators) {\n            if (!this.isArgumentValid('name', name, 'string') ||\n                !this.isArgumentValid('validators', validators, 'object')) return;\n\n            this.customValidators[name] = validators;\n        }\n\n        /**\n         * Method for removing custom validator\n         * @param {string} name - The name attribute value of a form element\n         */\n        removeCustomValidator(name) {\n            if (!this.isArgumentValid('name', name, 'string')) return;\n\n            delete this.customValidators[name];\n        }\n\n        /**\n         * Method for removing multiple custom validators\n         * @param {string} name - The name attribute value of a form element\n         */\n        removeCustomValidators(names) {\n            if (!this.isArgumentValid('names', names) || !(names instanceof Array)) return;\n\n            for (const name of names) {\n                if (typeof name !== 'string') {\n                    console.warn(`Found a \"${name}\" insthe array with \"names\" that is not a string. Will ignore it!`);\n                    continue;\n                }\n\n                delete this.customValidators[name];\n            }\n        }\n\n        /**\n         * Will serialize the form data by traversing all the form element tree\n         * @returns {string}\n         */\n        getFormSerializedData(formElements) {\n            const params = new URLSearchParams();\n\n            //Serialize the data if there is any set on the submit button\n            this.serializeSubmitButtonElementData(params);\n\n            for (const formElement of formElements) {\n                if (!this.toCustomElement(formElement).willSerialize()) continue;\n                this.serializeElementData(formElement, params);\n            }\n\n            return params.toString();\n        }\n\n        /**\n         * Will serialize the data from the submit button if it has value attribute and it is <button> or <input type=\"submit\"/>.\n         * @param {URLSearchParams} params\n         */\n        serializeSubmitButtonElementData(params) {\n            if (!this.currentSubmitButton) return;\n\n            const tagName = this.currentSubmitButton.tagName.toLowerCase();\n            if (VALID_SUBMIT_ELEMENT_TAGS.has(tagName)) return;\n\n            if (this.currentSubmitButton.hasAttribute('name') && this.currentSubmitButton.hasAttribute('value')) {\n                params.append(this.currentSubmitButton.getAttribute('name'), this.currentSubmitButton.getAttribute('value'));\n            }\n        }\n\n        /**\n         * Will serialize data from a simple form element like input or textarea\n         * @param {HTMLElement} element\n         * @param {URLSearchParams} params\n         */\n        serializeSimpleElementData(element, params) {\n            const value = element.value;\n            if (!element.hasAttribute('name') || value === undefined) return;\n\n            const name = element.getAttribute('name');\n\n            if (!(value instanceof Array)) return params.append(name, element.value);\n            for (let option of element.value) {\n                params.append(name, option);\n            }\n        }\n\n        /**\n         * Will construct an object that has the same structure as the one on the hasErrors method\n         * including the custom validators\n         * @param {string} name - The name attribute value of a form element\n         * @param {HTMLElement|NativeElementValidator} element - The form element that will be passed as an argument to the custom validator method.\n         * @returns {Object<string,boolean>}\n         */\n        async getCustomErrorTypes(name, element) {\n            const customElementValidators = this.customValidators[name];\n            if (!customElementValidators || typeof customElementValidators !== 'object') return {};\n\n            const customErrorTypes = {};\n            for (const type in customElementValidators) {\n                if (!this.hasValidMethodProperty(customElementValidators[type])) continue;\n\n                if (element instanceof NativeElementValidator) {\n                    customErrorTypes[type] = await customElementValidators[type].method(element.element);\n                } else {\n                    customErrorTypes[type] = await customElementValidators[type].method(element);\n                }\n            }\n\n            return customErrorTypes;\n        }\n\n        /**\n         * Checks if an element has validation errors and returns the error types.\n         * @param {HTMLElement} element\n         * @param {string} name\n         * @returns {object}\n        */\n        async hasErrors(element, name) {\n            const customErrorTypes = await this.getCustomErrorTypes(name, element);\n\n            const errorTypes = {\n                notAForm: !element.isFormElement(),\n                tooLong: element.tooLong(),\n                tooShort: element.tooShort(),\n                rangeOverflow: element.rangeOverflow(),\n                rangeUnderflow: element.rangeUnderflow(),\n                valueMissing: element.valueMissing(),\n                nameMissing: element.nameMissing(),\n                badURL: element.isBadURL(),\n                badEmail: element.isBadEmail(),\n                customError: element.customError(),\n                ...customErrorTypes\n            };\n\n            const errors = Object.keys(errorTypes).filter((name) => {\n                if (errorTypes[name]) return name;\n            });\n\n            return { hasError: !!errors.length, errors: errors };\n        }\n\n        /**\n         * Creates an instance of a NativeElementValidator to wrap a native HTMLElement\n         * @param {HTMLElement} element\n         * @returns {NativeElementValidator | HTMLElement}\n        */\n        toCustomElement(element) {\n            if (!(element instanceof CustomElementValidator)) element = new NativeElementValidator(element);\n            return element;\n        }\n\n        /**\n         * Will serialize the data from form element\n         * @param {HTMLElement} element\n         * @param {URLSearchParams} params\n         */\n        serializeElementData(element, params) {\n            if (element.hasAttribute('disabled')) return;\n            return this.serializeSimpleElementData(element, params);\n        }\n\n        /**\n         * Method for hiding the error tooltip\n         */\n        hideTooltip() {\n            if (this.tooltip && this.tooltip.parentElement) {\n                this.tooltip.parentElement.removeChild(this.tooltip);\n            }\n        }\n\n        /**\n         * Creates a <gameface-tooltip> element, sets its message and shows it on top\n         * of given element.\n         *\n         * @param {string} errorMessage\n         * @param {HTMLElement} element\n         * @param {HTMLElement} errorDisplayElement\n        */\n        showError(errorMessage, element, errorDisplayElement) {\n            if (!errorMessage) return;\n\n            if (errorDisplayElement) {\n                errorDisplayElement.textContent = errorMessage;\n                return;\n            }\n\n            this.tooltip = document.createElement('gameface-tooltip');\n            this.tooltip.targetElement = element;\n            this.tooltip.setAttribute('off', 'click');\n            const tooltipContent = document.createElement('div');\n            tooltipContent.setAttribute('slot', 'message');\n            tooltipContent.textContent = errorMessage;\n            this.tooltip.appendChild(tooltipContent);\n\n            document.body.appendChild(this.tooltip);\n\n            requestAnimationFrame(() => {\n                this.tooltip.show();\n            });\n        }\n\n        /**\n         * Checks whether the element is valid gameface-form-control element\n         * @param {HTMLElement} element\n         * @returns {boolean}\n         */\n        isValidFormElement(element) {\n            const tagName = element.tagName.toLowerCase();\n\n            return VALID_FORM_CONTROL_ELEMENT_TAGS.has(tagName) || VALID_FORM_CONTROL_CUSTOM_ELEMENT_TAGS.has(tagName);\n        }\n\n        /**\n         * Checks whether the element is submit button\n         * @param {HTMLElement} element\n         * @returns {boolean}\n         */\n        isElementUsedToSubmit(element) {\n            return element.getAttribute('type') === 'submit';\n        }\n\n        /**\n         * Will dispatch a custom event from the gameface-form-control element about request loadend holding the response event.\n         * We need custom event here in order to send response event to the user.\n         * @param {ProgressEvent} event - The event from the XMLHttpRequest\n         */\n        onRequestLoadEnd(event) {\n            const loadEndEvent = new CustomEvent('loadend', { detail: event });\n            this.dispatchEvent(loadEndEvent);\n            if (this.onload) this.onload(loadEndEvent);\n            // prepare the xhr for a next request\n            this.xhr = new XMLHttpRequest();\n        }\n\n        /**\n         * Will create a XMLHttpRequest to the server\n         * @param {string} type - The request type. Either 'GET' or 'POST'\n         * @param {string} body - The body of the request that will be send\n         * @param {string} action - The url where that will be requested\n         */\n        makeRequest(type, body, action) {\n            this.xhr.open(type, action);\n            this.xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n            this.xhr.onloadend = this.onRequestLoadEnd.bind(this);\n            if (body) {\n                this.xhr.send(body);\n            } else {\n                this.xhr.send();\n            }\n        }\n\n        /**\n         * Checks the validator method\n         * @param {Validator} validator\n         * @returns {boolean}\n         */\n        hasValidMethodProperty(validator) {\n            return validator !== undefined && validator.method && typeof validator.method === 'function';\n        }\n\n        /**\n         * Checks the validator error message\n         * @param {Validator} validator\n         * @returns {boolean}\n         */\n        hasValidMessageProperty(validator) {\n            return validator !== undefined && validator.errorMessage && typeof validator.errorMessage === 'function';\n        }\n\n        /**\n         * Will return the validator object by the error type\n         * @param {Validators} elementCustomValidators \n         * @param {string} errorType\n         * @returns {Validator}\n         */\n        getCustomValidatorObject(elementCustomValidators, errorType) {\n            if (!elementCustomValidators ||\n                !elementCustomValidators[errorType] ||\n                typeof elementCustomValidators[errorType] !== 'object') return;\n\n            return elementCustomValidators[errorType];\n        }\n\n        /**\n         * Will get the error message related to the validator\n         * @param {string} errorType\n         * @param {HTMLElement|NativeElementValidator} element\n         * @param {Validators} customValidators \n         * @returns {string}\n         */\n        getErrorMessage(errorType, element, customValidators) {\n            const customValidator = this.getCustomValidatorObject(customValidators, errorType);\n            const getErrorMessageCallback = this.hasValidMessageProperty(customValidator) ?\n                customValidator.errorMessage :\n                errorMessages.get(errorType);\n\n            if (typeof getErrorMessageCallback !== 'function') return '';\n\n            if (element instanceof NativeElementValidator) {\n                return getErrorMessageCallback(element.element);\n            }\n\n            return getErrorMessageCallback(element);\n        }\n\n        /**\n         * Will hide the tooltip and reset the elements set for displaying errors\n         */\n        resetErrors() {\n            this.hideTooltip();\n\n            for (const name in this.errorDisplayElements) {\n                const element = this.errorDisplayElements[name];\n                if (!element) continue;\n\n                element.textContent = '';\n            }\n        }\n\n        /**\n         * Will check if all the elements are valid\n         * @param {Array[HTMLElement]} formElements - All the elements of the form component\n         * @returns {boolean}\n         */\n        async isFormValid(formElements) {\n            for (const element of formElements) {\n                if (!this.toCustomElement(element).willSerialize()) continue;\n\n                const name = element.name || element.getAttribute('name');\n                const validation = await this.hasErrors(this.toCustomElement(element), name);\n                if (!validation.hasError) continue;\n\n                let errorMessage = '';\n                const customElementValidators = this.customValidators[name];\n\n                for (let errorType of validation.errors) {\n                    errorMessage += this.getErrorMessage(errorType, element, customElementValidators);\n                }\n\n                this.showError(errorMessage, element, this.errorDisplayElements[name]);\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Will handle submit of the form control\n         * @param {MouseEvent} event\n         */\n        async submit(event) {\n            this.resetErrors();\n\n            //Dispatch submit event to the form as it is by standard\n            const submitEvent = new Event('submit', { cancelable: true });\n            if (!this.dispatchEvent(submitEvent)) return;\n            if (this.onsubmit && typeof this.onsubmit === 'function') {\n                this.onsubmit(submitEvent);\n                if (submitEvent.defaultPrevented) return;\n            }\n\n            const formElementsCache = this.formElements;\n\n            if (!await this.isFormValid(formElementsCache)) return;\n\n            this.currentSubmitButton = event.currentTarget;\n            switch (this.method.toLowerCase()) {\n                case formMethods.GET.toLowerCase():\n                    return this.makeRequest(formMethods.GET, null, `${this.action}?${this.getFormSerializedData(formElementsCache)}`)\n                case formMethods.POST.toLowerCase():\n                    return this.makeRequest(formMethods.POST, this.getFormSerializedData(formElementsCache), this.action)\n                default:\n                    console.warn('Unable to submit form. The form method is not \"GET\" or \"POST\"!');\n            }\n        }\n\n        /**\n         * Will traverse the gameface-form-control element tree and execute a callback when element is found.\n         * This method is used to prevent performance issues when used querySelector multiple times.\n         * @param {HTMLElement} root\n         * @param {Function} elementCallback - Callback that will be executed for each child element of the root\n         */\n        traverseFormElements(root, elementCallback, args = []) {\n            if (!root.children) return;\n\n            //Consider iterating the tree with queue if there are stack issues with the recursion\n            for (let i = 0, len = root.children.length; i < len; i++) {\n                const element = root.children[i];\n\n                elementCallback(element, ...args);\n\n                this.traverseFormElements(element, elementCallback, args);\n            }\n        }\n\n        /**\n         * Callback that will add click event to the gameface-form-control elements that are having submit type attribute\n         * @param {HTMLElement} element\n         */\n        addSubmitElementListener(element) {\n            if (VALID_SUBMIT_ELEMENT_TAGS.has(element.tagName.toLowerCase()) && element.getAttribute('type') === 'submit') {\n                element.addEventListener('click', this.submit.bind(this));\n            }\n        }\n\n        /**\n         * Will add click events to all the submit elements inside the form control\n         */\n        initSubmitElements() {\n            this.traverseFormElements(this, (formElement) => {\n                this.addSubmitElementListener(formElement);\n            });\n        }\n\n        connectedCallback() {\n            this.initSubmitElements();\n        }\n    }\n\n    components__default[\"default\"].defineCustomElement('gameface-form-control', GamefaceFormControl);\n\n    return GamefaceFormControl;\n\n}));\n\n\n//# sourceURL=webpack://gameuicomponents/./components/form-control/umd/form-control.development.js?");

/***/ }),

/***/ "./lib/components.js":
/*!***************************!*\
  !*** ./lib/components.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Coherent Labs AD. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nconst newLinesRegExp = new RegExp('^\\s+|\\s+$', 'g');\r\nconst NATIVE_TEXT_FIELD_ELEMENTS = ['input', 'textarea'];\r\n\r\nfunction isNativeTextField(element) {\r\n    return NATIVE_TEXT_FIELD_ELEMENTS.indexOf(element.tagName.toLowerCase()) > -1;\r\n}\r\n\r\nconst components = function () {\r\n    // This is the base class that holds all functionality shared between custom components\r\n    // and native elements\r\n    class Validator {\r\n        /**\r\n         * Check if element is child of a form\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static isFormElement(element) {\r\n            element = element.parentElement;\r\n            while (element) {\r\n                if (element.tagName === 'GAMEFACE-FORM-CONTROL' || element.tagName === 'gameface-form-control') return true;\r\n                element = element.parentElement;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check if element value is bigger than element maxlength\r\n         * @returns {boolean}\r\n         */\r\n        static tooLong() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check if element value is less than element minlength\r\n         * @returns {boolean}\r\n         */\r\n        static tooShort() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if the value of an element is bigger than its max attribute\r\n         * @returns {boolean}\r\n        */\r\n        static rangeOverflow() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if the value of an element is smaller than its min attribute\r\n         * @returns {boolean}\r\n        */\r\n        static rangeUnderflow() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check if element is required and its value is missing\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static valueMissing(element) {\r\n            return element.hasAttribute('required') && !element.value;\r\n        }\r\n\r\n        /**\r\n         * Check if element name is missing\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n         */\r\n        static nameMissing(element) {\r\n            return !element.name && !element.getAttribute('name');\r\n        }\r\n\r\n        /**\r\n         * Check if an element is required\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n        */\r\n        static isRequired(element) {\r\n            return element.hasAttribute('required');\r\n        }\r\n\r\n        static customError() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if element is going to be serialized.\r\n         * If an element doesn't have a name it will not be serialized.\r\n         * Used to determine if an element should be validated.\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean}\r\n        */\r\n        static willSerialize(element) {\r\n            return this.nameMissing(element) ? false : true;\r\n        }\r\n\r\n        static isBadURL() {\r\n            return false;\r\n        }\r\n\r\n        static isBadEmail() {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The NativeElementValidator uses the methods from the Validator class\r\n     * All native elements tha don't support methods like isFormElement, tooLong, tooShort\r\n     * etc.. will be wrapped in this class in order to enable us to validate native and\r\n     * custom elements using the same methods.\r\n     * */\r\n    class NativeElementValidator {\r\n        constructor(element) {\r\n            this.element = element;\r\n        }\r\n\r\n        isFormElement() {\r\n            return Validator.isFormElement(this.element);\r\n        }\r\n\r\n        tooLong() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.tooLong(this.element);\r\n            return Validator.tooLong();\r\n        }\r\n\r\n        tooShort() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.tooShort(this.element);\r\n            return Validator.tooShort();\r\n        }\r\n\r\n        rangeOverflow() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.rangeOverflow(this.element);\r\n            return Validator.rangeOverflow()\r\n        }\r\n\r\n        rangeUnderflow() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.rangeUnderflow(this.element);\r\n            return Validator.rangeUnderflow();\r\n        }\r\n\r\n        valueMissing() {\r\n            return Validator.valueMissing(this.element);\r\n        }\r\n\r\n        nameMissing() {\r\n            return Validator.nameMissing(this.element);\r\n        }\r\n\r\n        customError() {\r\n            return Validator.customError();\r\n        }\r\n\r\n        isRequired() {\r\n            return Validator.isRequired(this.element);\r\n        }\r\n\r\n        willSerialize() {\r\n            return Validator.willSerialize(this.element);\r\n        }\r\n\r\n        isBadEmail() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.isBadEmail(this.element);\r\n            return false;\r\n        }\r\n\r\n        isBadURL() {\r\n            if (isNativeTextField(this.element)) return TextFieldValidator.isBadURL(this.element);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The CustomElementValidator is inherited by custom elements in order to gain the\r\n     * validation function from the Validator class.\r\n     * This class can not be used to wrap the native elements as it inherits the\r\n     * HTMLElement which can not be instantiated using the new keyword.\r\n    */\r\n    class CustomElementValidator extends HTMLElement {\r\n        isFormElement() {\r\n            return Validator.isFormElement(this);\r\n        }\r\n\r\n        tooLong() {\r\n            return Validator.tooLong(this);\r\n        }\r\n\r\n        tooShort() {\r\n            return Validator.tooShort(this);\r\n        }\r\n\r\n        valueMissing() {\r\n            return Validator.valueMissing(this);\r\n        }\r\n\r\n        nameMissing() {\r\n            return Validator.nameMissing(this);\r\n        }\r\n\r\n        customError() {\r\n            return Validator.customError();\r\n        }\r\n\r\n        isRequired() {\r\n            return Validator.isRequired(this);\r\n        }\r\n\r\n        rangeOverflow() {\r\n            return Validator.rangeOverflow(this);\r\n        }\r\n\r\n        rangeUnderflow() {\r\n            return Validator.rangeUnderflow(this);\r\n        }\r\n\r\n        willSerialize() {\r\n            return Validator.willSerialize(this);\r\n        }\r\n\r\n        isBadEmail() {\r\n            return Validator.isBadEmail(this);\r\n        }\r\n\r\n        isBadURL() {\r\n            return Validator.isBadURL(this);\r\n        }\r\n    }\r\n\r\n    class TextFieldValidator {\r\n        /**\r\n         * Most of the custom elements will not need this check however,\r\n         * we call all validation methods in order to determine if an element is valid.\r\n         * Each element that needs this check implements it itself.\r\n         * @returns {boolean}\r\n         */\r\n        static tooLong(element) {\r\n            const maxLength = element.getAttribute('maxlength');\r\n            if (!maxLength) return false;\r\n            return element.value.length > parseFloat(maxLength);\r\n        }\r\n\r\n        /**\r\n        * Most of the custom elements will not need this check however,\r\n        * we call all validation methods in order to determine if an element is valid.\r\n        * Each element that needs this check implements it itself.\r\n        * @returns {boolean}\r\n        */\r\n        static tooShort(element) {\r\n            const minLength = element.getAttribute('minlength');\r\n            if (!minLength) return false;\r\n            return element.value.length < parseFloat(minLength);\r\n        }\r\n\r\n        /**\r\n        * Most of the custom elements will not need this check however,\r\n        * we call all validation methods in order to determine if an element is valid.\r\n        * Each element that needs this check implements it itself.\r\n        * @returns {boolean}\r\n        */\r\n        static rangeOverflow(element) {\r\n            const max = element.getAttribute('max');\r\n            if (!max) return false;\r\n            return parseFloat(element.value) > parseFloat(max);\r\n        }\r\n\r\n        /**\r\n         * Most of the custom elements will not need this check however,\r\n         * we call all validation methods in order to determine if an element is valid.\r\n         * Each element that needs this check implements it itself.\r\n         * @returns {boolean}\r\n         */\r\n        static rangeUnderflow(element) {\r\n            const min = element.getAttribute('min');\r\n            if (!min) return false;\r\n            return parseFloat(element.value) < parseFloat(min);\r\n        }\r\n\r\n        static isBadURL(element) {\r\n            if (element.getAttribute('type') !== 'url') return false;\r\n            const pattern = element.pattern || element.getAttribute('pattern');\r\n            if (!pattern) return false;\r\n            if (!element.value.match(pattern)) return true;\r\n            return false;\r\n        }\r\n\r\n        static isBadEmail(element) {\r\n            if (element.getAttribute('type') !== 'email') return false;\r\n            if (!element.value.match('@')) return true;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    const GF_COMPONENT_SLOT_TAG_NAME = 'component-slot';\r\n    const KEYCODES = {\r\n        DOWN: 40,\r\n        LEFT: 37,\r\n        RIGHT: 39,\r\n        UP: 38,\r\n        HOME: 36,\r\n        END: 35,\r\n        ENTER: 13,\r\n        ESCAPE: 27,\r\n        TAB: 9,\r\n        SHIFT: 16,\r\n        CTRL: 17,\r\n        SPACE: 32,\r\n        PAGE_UP: 33,\r\n        PAGE_DOWN: 34,\r\n    };\r\n\r\n    class GamefaceComponents {\r\n        constructor() {\r\n            this.definedElements = {};\r\n            this.imported = this.imported || [];\r\n            this.KEYCODES = KEYCODES;\r\n            this.cachedComponents = {};\r\n\r\n            this.CustomElementValidator = CustomElementValidator;\r\n            this.NativeElementValidator = NativeElementValidator;\r\n            this.TextFieldValidator = TextFieldValidator;\r\n            this.Validator = Validator;\r\n        }\r\n\r\n        /**\r\n         * Create and add a script tag with given url.\r\n         * @param {string} script\r\n        */\r\n        importScript(url) {\r\n            let script = document.createElement('script');\r\n            script.setAttribute('src', url);\r\n            document.body.appendChild(script);\r\n        }\r\n\r\n        /**\r\n         * Loads an html by given url.\r\n         * @param {string} url\r\n         * @returns {promise} resolved with the html as text.\r\n        */\r\n        loadHTML(url) {\r\n            return this.loadResource(url).then((result) => {\r\n                return result.template;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Creates a promise which resolves when a custom element was defined.\r\n         * Saves the promise for each defined component.\r\n         * @param {string} name - the name of the custom element\r\n         * @returns {promise} - the previously saved promise it any or a new one\r\n        */\r\n        whenDefined(name) {\r\n            if (this.definedElements[name] !== undefined) {\r\n                return this.definedElements[name].promise;\r\n            }\r\n\r\n            const defined = this.definedElements[name] = {};\r\n            defined.promise = new Promise((resolve, reject) => {\r\n                defined.resolve = resolve;\r\n                defined.reject = reject;\r\n            });\r\n            return defined.promise;\r\n        }\r\n\r\n        /**\r\n         * Defines a custom element.\r\n         * @param {string} name - the name of the element.\r\n         * @param {Object} element - the object which describes the element.\r\n        */\r\n        defineCustomElement(name, element) {\r\n            if (this.definedElements[name]) return;\r\n            this.whenDefined(name);\r\n            customElements.define(name, element);\r\n            this.definedElements[name].resolve(element);\r\n        }\r\n\r\n        /**\r\n         * Imports a component by given url.\r\n         * It will automatically try to import style.css and script.js if these\r\n         * files' names were not explicitly specified.\r\n         * @param {string} url - the url of the component\r\n        */\r\n        importComponent(url) {\r\n            requestAnimationFrame(() => {\r\n                this.importScript(url + '/script.js');\r\n            })\r\n        }\r\n\r\n        removeSlashes(path) {\r\n            return path.replace(/[/|\\\\]/g, '');\r\n        }\r\n\r\n        /**\r\n         * Remove new lines from the beginning of templates,\r\n         * because template.firstChild.cloneNode will clone an empty\r\n         * string and will return an empty template.\r\n        */\r\n        removeNewLines(template) {\r\n            return template.replace(newLinesRegExp, '').trim();\r\n        }\r\n\r\n        /**\r\n         * Removes the copyright notice from the template\r\n         * @param {string} template\r\n         * @returns {string} the template without the copyright notice\r\n        */\r\n        removeCopyrightNotice(template) {\r\n            return template.replace(`<!--Copyright (c) Coherent Labs AD. All rights reserved. Licensed under the MIT License. See License.txt in the project root for license information. -->`, '').trim();\r\n        }\r\n\r\n        /**\r\n         * Used when the element has already been rendered.\r\n         * Return the already rendered template instead of\r\n         * loading and slotting its elements.\r\n         *\r\n         * @param {HTMLElement} component - the component that was rendered\r\n         * @returns {Promise<HTMLElement>} - a promise that will resolve with the rendered template\r\n        */\r\n        resolveWithTemplate(component) {\r\n            return new Promise((resolve) => {\r\n                resolve({\r\n                    template: component.template.cloneNode(true),\r\n                    url: component.url\r\n                });\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Uses an XMLHttpRequest to load an external file.\r\n         * @param {string} url - the url of the file.\r\n         * @returns {promise} - a promise that is resolved with the file's text content.\r\n        */\r\n        loadResource(component) {\r\n            if (component.template && typeof component.template === 'string') {\r\n                if (component.isRendered) return this.resolveWithTemplate(component);\r\n                const element = document.createElement('div');\r\n                const template = this.removeCopyrightNotice(component.template);\r\n                element.innerHTML = this.removeNewLines(template);\r\n\r\n                return new Promise((resolve) => {\r\n                    resolve({\r\n                        template: element.firstChild.cloneNode(true),\r\n                        url: component.url\r\n                    });\r\n                });\r\n            }\r\n\r\n            if (typeof component.template === 'object' && component.isRendered) {\r\n                return this.resolveWithTemplate(component);\r\n            }\r\n\r\n            if (window.__optimize) {\r\n                const id = this.removeSlashes(component.url);\r\n                const element = document.getElementById(id).firstChild;\r\n                // fallback to XHR\r\n                if (!element) return this.requestResource(component.url);\r\n\r\n                return new Promise((resolve) => {\r\n                    resolve({ template: element.cloneNode(true), url: component.url });\r\n                });\r\n            }\r\n\r\n            return this.requestResource(component.url);\r\n        }\r\n\r\n\r\n        /**\r\n         * Execute an XMLHttpRequest to load a resource by url.\r\n         * @param {string} url - the path to the resource\r\n         * @returns {promise} - promise which resolves with the loaded resource\r\n        */\r\n        requestResource(url) {\r\n            const request = new XMLHttpRequest();\r\n            const promise = new Promise(function (resolve, reject) {\r\n                request.onload = (response) => {\r\n                    if (request.status == 200) {\r\n                        const tempEl = document.createElement('div');\r\n                        tempEl.innerHTML = request.responseText;\r\n                        resolve({ template: tempEl.firstChild.cloneNode(true), url: url });\r\n                    } else {\r\n                        reject(response);\r\n                    }\r\n                };\r\n                request.onerror = reject;\r\n            });\r\n            request.open('GET', url);\r\n            request.send();\r\n            return promise;\r\n        }\r\n\r\n        /**\r\n         * Recursively finds the slot elements in a given element.\r\n         * @param {HTMLElement} parent - the element which is searched for slots.\r\n         * @param {object} result - a key:value object containing the slot elements\r\n         * under their data-name as value:\r\n         * { <my-slot-name>: HTMLElement }\r\n         * @returns {Object} result\r\n        */\r\n        findSlots(parent, parentElName, result = {}) {\r\n            const children = parent.children;\r\n            const length = children.length;\r\n\r\n            for (let i = 0; i < length; ++i) {\r\n                const child = children[i];\r\n                const childTagName = child.tagName.toLowerCase();\r\n\r\n                if (child instanceof ComponentSlot) {\r\n                    const name = child.dataset.name;\r\n                    if (!result[name]) result[name] = [];\r\n                    result[name].push(child);\r\n                    this.findSlots(child, parentElName, result);\r\n                } else if (child.hasAttribute('slot')) {\r\n                    const slot = child.getAttribute('slot');\r\n                    if (!result[slot]) result[slot] = [];\r\n                    result[slot].push(child);\r\n                    this.findSlots(child, parentElName, result);\r\n                    // the scrollable container is the ONLY component that can hold\r\n                    // slots of another elements; we allow this in order achieve\r\n                    // better integration of the scrollbar inside other components\r\n                    // The WebComponents and the standard slot elements don't support\r\n                    // such behavior; an element handles only its own slots. The scrollable\r\n                    // container is an exception from this rule.\r\n                } else if (childTagName === 'gameface-scrollable-container'\r\n                    || (childTagName !== GF_COMPONENT_SLOT_TAG_NAME\r\n                        && parentElName !== childTagName\r\n                        && !this.definedElements[childTagName])) {\r\n                    // if the child is another nested element don't look for slots in it\r\n                    this.findSlots(child, parentElName, result);\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        replaceSlots(source, target) {\r\n            const fakeRoot = target[0];\r\n            if (source.length && fakeRoot.childNodes.length) {\r\n                while (fakeRoot.firstChild) {\r\n                    fakeRoot.removeChild(fakeRoot.lastChild);\r\n                }\r\n            }\r\n            // remove the slot so that it can be replaced\r\n            const parent = fakeRoot.parentNode;\r\n            parent.removeChild(fakeRoot);\r\n\r\n            for (let i = 0; i < source.length; ++i) {\r\n                parent.appendChild(source[i]);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Transfers the slottable elements into their slots.\r\n         * @param {HTMLElement} source - the element containing the slottable elements.\r\n         * @param {HTMLElement} target - the element containing the slots elements.\r\n        */\r\n        transferContent(source, target) {\r\n            while (target.childNodes.length > 0) {\r\n                const nodes = target.childNodes;\r\n                target.removeChild(nodes[nodes.length - 1]);\r\n            }\r\n            while (source.childNodes.length > 0) {\r\n                const nodes = source.childNodes;\r\n                const node = nodes[0];\r\n                source.removeChild(node);\r\n                target.appendChild(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Renderes an element only if it wasn't rendered before that\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean} - true if it was rendered, false if not\r\n        */\r\n        renderOnce(element) {\r\n            if (element.isRendered) return false;\r\n\r\n            this.render(element);\r\n            element.isRendered = true;\r\n            return true;\r\n        }\r\n\r\n        /**\r\n        * Renders an element's content into its template.\r\n        * @param {HTMLElement} element - the element into which to render the content\r\n        */\r\n        render(element) {\r\n            const templateRoot = document.createElement('div')\r\n            templateRoot.appendChild(element.template);\r\n\r\n            const parentElName = element.tagName.toLowerCase();\r\n\r\n            const templateSlots = this.findSlots(templateRoot, parentElName);\r\n            const userSlots = this.findSlots(element, parentElName);\r\n\r\n            // use for...of instead of for...in for better performance\r\n            const userSlotsKeys = Object.keys(userSlots);\r\n            const templateSlotsKeys = Object.keys(templateSlots);\r\n\r\n            // there's no point in looping over userSlots if there aren't\r\n            // corresponding template slots\r\n            if (templateSlotsKeys.length) {\r\n                for (let userSlot of userSlotsKeys) {\r\n                    if (!userSlots[userSlot] || !templateSlots[userSlot]) continue;\r\n                    this.replaceSlots(userSlots[userSlot], templateSlots[userSlot]);\r\n                }\r\n            }\r\n\r\n            this.transferContent(templateRoot, element);\r\n        }\r\n\r\n        /**\r\n         * Delay the execution of a callback function by n amount of frames.\r\n         * Used to retrieve the computed styles of elements.\r\n         * @param {Function} callback - the function that will be executed.\r\n         * @param {number} count - the amount of frames that the callback execution\r\n         * should be delayed by.\r\n        */\r\n        waitForFrames(callback = () => { }, count = 3) {\r\n            if (count === 0) return callback();\r\n            count--;\r\n            requestAnimationFrame(() => this.waitForFrames(callback, count));\r\n        }\r\n    }\r\n\r\n    const components = new GamefaceComponents();\r\n\r\n    class ComponentImport extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n        }\r\n\r\n        connectedCallback() {\r\n            const url = `/components/${this.dataset.url}/`;\r\n            const componentName = `gameface-${this.dataset.url}`;\r\n\r\n            if (components.imported.indexOf(componentName) === -1) {\r\n                components.importComponent(url);\r\n                components.imported.push(componentName);\r\n            }\r\n            this.appendChild(document.createElement(componentName));\r\n        }\r\n    }\r\n\r\n    class ComponentSlot extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n\r\n            this.originalAppendChild = this.appendChild;\r\n            this.originalInsertBefore = this.insertBefore;\r\n            this.originalReplaceChild = this.replaceChild;\r\n            this.originalRemoveChild = this.removeChild;\r\n\r\n            this.appendChild = (node) => {\r\n                const child = this.originalAppendChild(node);\r\n                this.disptachSlotChange(child);\r\n\r\n                return child;\r\n            };\r\n\r\n            this.insertBefore = (newNode, referenceNode) => {\r\n                const child = this.originalInsertBefore(newNode, referenceNode);\r\n                this.disptachSlotChange(child);\r\n\r\n                return child;\r\n            };\r\n\r\n            this.replaceChild = (newChild, oldChild) => {\r\n                const replacedNode = this.originalReplaceChild(newChild, oldChild);\r\n                this.disptachSlotChange(replacedNode);\r\n\r\n                return replacedNode;\r\n            };\r\n\r\n            this.removeChild = (child) => {\r\n                const removedNode = this.originalRemoveChild(child);\r\n                this.disptachSlotChange(removedNode);\r\n\r\n                return removedNode;\r\n            };\r\n        }\r\n\r\n        disptachSlotChange(child) {\r\n            this.dispatchEvent(new CustomEvent('slotchange'), {\r\n                target: this,\r\n                child: child\r\n            });\r\n        }\r\n    }\r\n\r\n    components.defineCustomElement('component-import', ComponentImport);\r\n    components.defineCustomElement(GF_COMPONENT_SLOT_TAG_NAME, ComponentSlot);\r\n\r\n    return components;\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (components());\n\n//# sourceURL=webpack://gameuicomponents/./lib/components.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./components/form-control/demo/demo.js");
/******/ 	
/******/ })()
;