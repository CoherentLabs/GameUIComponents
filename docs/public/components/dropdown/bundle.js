/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./components/dropdown/demo/demo.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./components/dropdown/demo/demo.js":
/*!******************************************!*\
  !*** ./components/dropdown/demo/demo.js ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var coherent_gameface_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! coherent-gameface-components */ \"./components/dropdown/node_modules/coherent-gameface-components/components.js\");\n/* harmony import */ var _umd_dropdown_development_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../umd/dropdown.development.js */ \"./components/dropdown/umd/dropdown.development.js\");\n/* harmony import */ var _umd_dropdown_development_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_umd_dropdown_development_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var postmessage_polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! postmessage-polyfill */ \"./components/dropdown/node_modules/postmessage-polyfill/postmessage.js\");\n/* harmony import */ var postmessage_polyfill__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(postmessage_polyfill__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! whatwg-fetch */ \"./components/dropdown/node_modules/whatwg-fetch/fetch.js\");\n\n\n\n\n\nwindow.postMessage = function(message) {\n    Object(postmessage_polyfill__WEBPACK_IMPORTED_MODULE_2__[\"pm\"])({\n        origin: 'http://127.0.0.1/:3000',\n        target: window,\n        data: message\n    });\n};\n\n//# sourceURL=webpack:///./components/dropdown/demo/demo.js?");

/***/ }),

/***/ "./components/dropdown/node_modules/coherent-gameface-components/components.js":
/*!*************************************************************************************!*\
  !*** ./components/dropdown/node_modules/coherent-gameface-components/components.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst newLinesRegExp = new RegExp('^\\s+|\\s+$', 'g');\r\n\r\nconst components = function () {\r\n    const GF_COMPONENT_SLOT_TAG_NAME = 'component-slot';\r\n    const KEYCODES = {\r\n        DOWN: 40,\r\n        LEFT: 37,\r\n        RIGHT: 39,\r\n        UP: 38,\r\n        HOME: 36,\r\n        END: 35,\r\n        ENTER: 13,\r\n        ESCAPE: 27,\r\n        TAB: 9,\r\n        SHIFT: 16,\r\n        CTRL: 17,\r\n        SPACE: 32,\r\n    };\r\n\r\n    class GamefaceComponents {\r\n        constructor() {\r\n            this.definedElements = {};\r\n            this.imported = this.imported || [];\r\n            this.KEYCODES = KEYCODES;\r\n        }\r\n\r\n        /**\r\n         * Create and add a script tag with given url.\r\n         * @param {string} script\r\n        */\r\n        importScript(url) {\r\n            let script = document.createElement('script');\r\n            script.setAttribute('src', url);\r\n            document.body.appendChild(script);\r\n        }\r\n\r\n        /**\r\n         * Loads an html by given url.\r\n         * @param {string} url\r\n         * @returns {promise} resolved with the html as text.\r\n        */\r\n        loadHTML(url) {\r\n            return this.loadResource(url).then((result) => {\r\n                return result.template;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Creates a promise which resolves when a custom element was defined.\r\n         * Saves the promise for each defined component.\r\n         * @param {string} name - the name of the custom element\r\n         * @returns {promise} - the previously saved promise it any or a new one\r\n        */\r\n        whenDefined(name) {\r\n            if (this.definedElements[name] !== undefined) {\r\n                return this.definedElements[name].promise;\r\n            }\r\n\r\n            const defined = this.definedElements[name] = {};\r\n            defined.promise = new Promise((resolve, reject) => {\r\n                defined.resolve = resolve;\r\n                defined.reject = reject;\r\n            });\r\n            return defined.promise;\r\n        }\r\n\r\n        /**\r\n         * Defines a custom element.\r\n         * @param {string} name - the name of the element.\r\n         * @param {Object} element - the object which describes the element.\r\n        */\r\n        defineCustomElement(name, element) {\r\n            this.whenDefined(name);\r\n            customElements.define(name, element);\r\n            this.definedElements[name].resolve(element);\r\n        }\r\n\r\n        /**\r\n         * Imports a component by given url.\r\n         * It will automatically try to import style.css and script.js if these\r\n         * files' names were not explicitly specified.\r\n         * @param {string} url - the url of the component\r\n        */\r\n        importComponent(url) {\r\n            requestAnimationFrame(() => {\r\n                this.importStyle(url + '/style.css');\r\n                this.importScript(url + '/script.js');\r\n            })\r\n        }\r\n\r\n        removeSlashes(path) {\r\n            return path.replace(/[/|\\\\]/g, '');\r\n        }\r\n\r\n        /**\r\n         * Remove new lines from the beginning of templates,\r\n         * because template.firstChild.cloneNode will clone an empty\r\n         * string and will return an empty template.\r\n        */\r\n        removeNewLines(template) {\r\n            return template.replace(newLinesRegExp, '');\r\n        }\r\n\r\n        /**\r\n         * Used when the element has already been rendered.\r\n         * Return the already rendered template instead of\r\n         * loading and slotting its elements.\r\n         *\r\n         * @param {HTMLElement} component - the component that was rendered\r\n         * @returns {Promise<HTMLElement>} - a promise that will resolve with the rendered template\r\n        */\r\n        resolveWithTemplate(component) {\r\n            return new Promise((resolve) => {\r\n                resolve({\r\n                    template: component.template.cloneNode(true),\r\n                    url: component.url\r\n                });\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Uses an XMLHttpRequest to load an external file.\r\n         * @param {string} url - the url of the file.\r\n         * @returns {promise} - a promise that is resolved with the file's text content.\r\n        */\r\n       loadResource(component) {\r\n        if (component.template) {\r\n            if(component.isRendered) return this.resolveWithTemplate(component);\r\n            const element = document.createElement('div');\r\n            element.innerHTML = this.removeNewLines(component.template);\r\n\r\n            return new Promise((resolve) => {\r\n                resolve({\r\n                    template: element.firstChild.cloneNode(true),\r\n                    url: component.url\r\n                });\r\n            });\r\n        }\r\n\r\n        if (window.__optimize) {\r\n            const id = this.removeSlashes(component.url);\r\n            const element = document.getElementById(id).firstChild;\r\n            // fallback to XHR\r\n            if (!element) return this.requestResource(component.url);\r\n\r\n            return new Promise((resolve) => {\r\n                resolve({template: element.cloneNode(true), url: component.url});\r\n            });\r\n        }\r\n\r\n        return this.requestResource(component.url);\r\n    }\r\n\r\n\r\n        /**\r\n         * Execute an XMLHttpRequest to load a resource by url.\r\n         * @param {string} url - the path to the resource\r\n         * @returns {promise} - promise which resolves with the loaded resource\r\n        */\r\n        requestResource(url) {\r\n            const request = new XMLHttpRequest();\r\n            const promise = new Promise(function (resolve, reject) {\r\n                request.onload = (response) => {\r\n                    if (request.status == 200) {\r\n                        const tempEl = document.createElement('div');\r\n                        tempEl.innerHTML = request.responseText;\r\n                        resolve({template: tempEl.firstChild.cloneNode(true), url: url});\r\n                    } else {\r\n                        reject(response);\r\n                    }\r\n                };\r\n                request.onerror = reject;\r\n            });\r\n            request.open('GET', url);\r\n            request.send();\r\n            return promise;\r\n        }\r\n\r\n        /**\r\n         * Appends a <link> element which imports a given css file.\r\n         * @param {string} url - the source to a given css file.\r\n        */\r\n        importStyle(url) {\r\n            // this style was already added\r\n            if (document.querySelector(`[href=\"${url}\"]`)) return;\r\n\r\n            let style = document.createElement('link');\r\n            style.setAttribute('rel', 'stylesheet');\r\n            style.setAttribute('type', 'text/css');\r\n            style.setAttribute('href', url);\r\n            document.head.insertBefore(style, document.head.firstChild);\r\n        }\r\n\r\n        importStyleTag(componentName, css) {\r\n            if (document.querySelector(`[data-name=\"${componentName}\"]`)) return;\r\n\r\n            let style = document.createElement('style');\r\n            style.setAttribute('data-name', componentName)\r\n            style.textContent = css;\r\n            document.head.insertBefore(style, document.head.firstChild);\r\n        }\r\n\r\n        /**\r\n         * Recursively finds the slot elements in a given element.\r\n         * @param {HTMLElement} parent - the element which is searched for slots.\r\n         * @param {object} result - a key:value object containing the slot elements\r\n         * under their data-name as value:\r\n         * { <my-slot-name>: HTMLElement }\r\n         * @returns {Object} result\r\n        */\r\n        findSlots(parent, parentElName, result = {}) {\r\n            const children = parent.children;\r\n            const length = children.length;\r\n\r\n            debugger\r\n\r\n            for (let i = 0; i < length; ++i) {\r\n                const child = children[i];\r\n                const childTagName = child.tagName.toLowerCase();\r\n\r\n                console.log('childTagName', childTagName)\r\n\r\n                if (child instanceof ComponentSlot) {\r\n                    const name = child.dataset.name;\r\n                    if (!result[name]) result[name] = [];\r\n                    result[name].push(child);\r\n                    this.findSlots(child, parentElName, result);\r\n                } else if (child.hasAttribute('slot')) {\r\n                    const slot = child.getAttribute('slot');\r\n                    if (!result[slot]) result[slot] = [];\r\n                    result[slot].push(child);\r\n                    this.findSlots(child, parentElName, result);\r\n                } else if (childTagName === 'scrollable-container'\r\n                     || (childTagName !== GF_COMPONENT_SLOT_TAG_NAME\r\n                     && parentElName !== childTagName\r\n                     && !this.definedElements[childTagName])) {\r\n                    // if the child is another nested element don't look for slots in it\r\n                    this.findSlots(child, parentElName, result);\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        replaceSlots(source, target) {\r\n            const fakeRoot = target[0];\r\n            if (source.length && fakeRoot.childNodes.length) {\r\n                while (fakeRoot.firstChild) {\r\n                    fakeRoot.removeChild(fakeRoot.lastChild);\r\n                }\r\n            }\r\n            // remove the slot so that it can be replaced\r\n            const parent = fakeRoot.parentNode;\r\n            parent.removeChild(fakeRoot);\r\n\r\n            for (let i = 0; i < source.length; ++i) {\r\n                parent.appendChild(source[i]);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Transfers the slottable elements into their slots.\r\n         * @param {HTMLElement} source - the element containing the slottable elements.\r\n         * @param {HTMLElement} target - the element containing the slots elements.\r\n        */\r\n        transferContent(source, target) {\r\n            while (target.childNodes.length > 0) {\r\n                const nodes = target.childNodes;\r\n                target.removeChild(nodes[nodes.length - 1]);\r\n            }\r\n            while (source.childNodes.length > 0) {\r\n                const nodes = source.childNodes;\r\n                const node = nodes[0];\r\n                source.removeChild(node);\r\n                target.appendChild(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Renderes an element only if it wasn't rendered before that\r\n         * @param {HTMLElement} element\r\n         * @returns {boolean} - true if it was rendered, false if not\r\n        */\r\n        renderOnce(element) {\r\n            if (element.isRendered) return false;\r\n\r\n            this.render(element);\r\n            element.isRendered = true;\r\n            return true;\r\n        }\r\n\r\n        /**\r\n        * Renders an element's content into its template.\r\n        * @param {HTMLElement} element - the element into which to render the content\r\n        */\r\n        render(element) {\r\n            const templateRoot = document.createElement('div')\r\n            templateRoot.appendChild(element.template);\r\n\r\n            const parentElName = element.tagName.toLowerCase();\r\n\r\n            const templateSlots = this.findSlots(templateRoot, parentElName);\r\n            const userSlots = this.findSlots(element, parentElName);\r\n\r\n            // use for...of instead of for...in for better performance\r\n            const userSlotsKeys = Object.keys(userSlots);\r\n            const templateSlotsKeys = Object.keys(templateSlots);\r\n\r\n            // there's no point in looping over userSlots if there aren't\r\n            // corresponding template slots\r\n            if (templateSlotsKeys.length) {\r\n                for (let userSlot of userSlotsKeys) {\r\n                    if (!userSlots[userSlot] || !templateSlots[userSlot]) continue;\r\n                    this.replaceSlots(userSlots[userSlot], templateSlots[userSlot]);\r\n                }\r\n            }\r\n\r\n            this.transferContent(templateRoot, element);\r\n        }\r\n    }\r\n\r\n    const components = new GamefaceComponents();\r\n\r\n    class ComponentImport extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n        }\r\n\r\n        connectedCallback() {\r\n            const url = `/components/${this.dataset.url}/`;\r\n            const componentName = `gameface-${this.dataset.url}`;\r\n\r\n            if (components.imported.indexOf(componentName) === -1) {\r\n                components.importComponent(url);\r\n                components.imported.push(componentName);\r\n            }\r\n            this.appendChild(document.createElement(componentName));\r\n        }\r\n    }\r\n\r\n    class ComponentSlot extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n\r\n            this.originalAppendChild = this.appendChild;\r\n            this.originalInsertBefore = this.insertBefore;\r\n            this.originalReplaceChild = this.replaceChild;\r\n            this.originalRemoveChild = this.removeChild;\r\n\r\n            this.appendChild = (node) => {\r\n                const child = this.originalAppendChild(node);\r\n                this.disptachSlotChange(child);\r\n\r\n                return child;\r\n            };\r\n\r\n            this.insertBefore = (newNode, referenceNode) => {\r\n                const child = this.originalInsertBefore(newNode, referenceNode);\r\n                this.disptachSlotChange(child);\r\n\r\n                return child;\r\n            };\r\n\r\n            this.replaceChild = (newChild, oldChild) => {\r\n                const replacedNode = this.originalReplaceChild(newChild, oldChild);\r\n                this.disptachSlotChange(replacedNode);\r\n\r\n                return replacedNode;\r\n            };\r\n\r\n            this.removeChild = (child) => {\r\n                const removedNode = this.originalRemoveChild(child);\r\n                this.disptachSlotChange(removedNode);\r\n\r\n                return removedNode;\r\n            };\r\n        }\r\n\r\n        disptachSlotChange(child) {\r\n            this.dispatchEvent(new CustomEvent('slotchange'), {\r\n                target: this,\r\n                child: child\r\n            });\r\n        }\r\n    }\r\n\r\n    components.defineCustomElement('component-import', ComponentImport);\r\n    components.defineCustomElement(GF_COMPONENT_SLOT_TAG_NAME, ComponentSlot);\r\n\r\n    return components;\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (components());\r\n\n\n//# sourceURL=webpack:///./components/dropdown/node_modules/coherent-gameface-components/components.js?");

/***/ }),

/***/ "./components/dropdown/node_modules/postmessage-polyfill/postmessage.js":
/*!******************************************************************************!*\
  !*** ./components/dropdown/node_modules/postmessage-polyfill/postmessage.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n The MIT License\n\n Copyright (c) 2010 Daniel Park (http://metaweb.com, http://postmessage.freebaseapps.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n **/\nvar NO_JQUERY = {};\n(function(window, $, undefined) {\n\n     if (!(\"console\" in window)) {\n         var c = window.console = {};\n         c.log = c.warn = c.error = c.debug = function(){};\n     }\n\n     if ($ === NO_JQUERY) {\n         // jQuery is optional\n         $ = {\n             fn: {},\n             extend: function() {\n                 var a = arguments[0];\n                 for (var i=1,len=arguments.length; i<len; i++) {\n                     var b = arguments[i];\n                     for (var prop in b) {\n                         a[prop] = b[prop];\n                     }\n                 }\n                 return a;\n             }\n         };\n     }\n\n     $.fn.pm = function() {\n         console.log(\"usage: \\nto send:    $.pm(options)\\nto receive: $.pm.bind(type, fn, [origin])\");\n         return this;\n     };\n\n     // send postmessage\n     $.pm = window.pm = function(options) {\n         pm.send(options);\n     };\n\n     // bind postmessage handler\n     $.pm.bind = window.pm.bind = function(type, fn, origin, hash, async_reply) {\n         pm.bind(type, fn, origin, hash, async_reply === true);\n     };\n\n     // unbind postmessage handler\n     $.pm.unbind = window.pm.unbind = function(type, fn) {\n         pm.unbind(type, fn);\n     };\n\n     // default postmessage origin on bind\n     $.pm.origin = window.pm.origin = null;\n\n     // default postmessage polling if using location hash to pass postmessages\n     $.pm.poll = window.pm.poll = 200;\n\n     var pm = {\n\n         send: function(options) {\n             var o = $.extend({}, pm.defaults, options),\n             target = o.target;\n             if (!o.target) {\n                 console.warn(\"postmessage target window required\");\n                 return;\n             }\n             if (!o.type) {\n                 console.warn(\"postmessage type required\");\n                 return;\n             }\n             var msg = {data:o.data, type:o.type};\n             if (o.success) {\n                 msg.callback = pm._callback(o.success);\n             }\n             if (o.error) {\n                 msg.errback = pm._callback(o.error);\n             }\n             if ((\"postMessage\" in target) && !o.hash) {\n                 pm._bind();\n                 target.postMessage(JSON.stringify(msg), o.origin || '*');\n             }\n             else {\n                 pm.hash._bind();\n                 pm.hash.send(o, msg);\n             }\n         },\n\n         bind: function(type, fn, origin, hash, async_reply) {\n           pm._replyBind ( type, fn, origin, hash, async_reply );\n         },\n       \n         _replyBind: function(type, fn, origin, hash, isCallback) {\n           if ((\"postMessage\" in window) && !hash) {\n               pm._bind();\n           }\n           else {\n               pm.hash._bind();\n           }\n           var l = pm.data(\"listeners.postmessage\");\n           if (!l) {\n               l = {};\n               pm.data(\"listeners.postmessage\", l);\n           }\n           var fns = l[type];\n           if (!fns) {\n               fns = [];\n               l[type] = fns;\n           }\n           fns.push({fn:fn, callback: isCallback, origin:origin || $.pm.origin});\n         },\n\n         unbind: function(type, fn) {\n             var l = pm.data(\"listeners.postmessage\");\n             if (l) {\n                 if (type) {\n                     if (fn) {\n                         // remove specific listener\n                         var fns = l[type];\n                         if (fns) {\n                             var m = [];\n                             for (var i=0,len=fns.length; i<len; i++) {\n                                 var o = fns[i];\n                                 if (o.fn !== fn) {\n                                     m.push(o);\n                                 }\n                             }\n                             l[type] = m;\n                         }\n                     }\n                     else {\n                         // remove all listeners by type\n                         delete l[type];\n                     }\n                 }\n                 else {\n                     // unbind all listeners of all type\n                     for (var i in l) {\n                       delete l[i];\n                     }\n                 }\n             }\n         },\n\n         data: function(k, v) {\n             if (v === undefined) {\n                 return pm._data[k];\n             }\n             pm._data[k] = v;\n             return v;\n         },\n\n         _data: {},\n\n         _CHARS: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\n\n         _random: function() {\n             var r = [];\n             for (var i=0; i<32; i++) {\n                 r[i] = pm._CHARS[0 | Math.random() * 32];\n             };\n             return r.join(\"\");\n         },\n\n         _callback: function(fn) {\n             var cbs = pm.data(\"callbacks.postmessage\");\n             if (!cbs) {\n                 cbs = {};\n                 pm.data(\"callbacks.postmessage\", cbs);\n             }\n             var r = pm._random();\n             cbs[r] = fn;\n             return r;\n         },\n\n         _bind: function() {\n             // are we already listening to message events on this w?\n             if (!pm.data(\"listening.postmessage\")) {\n                 if (window.addEventListener) {\n                     window.addEventListener(\"message\", pm._dispatch, false);\n                 }\n                 else if (window.attachEvent) {\n                     window.attachEvent(\"onmessage\", pm._dispatch);\n                 }\n                 pm.data(\"listening.postmessage\", 1);\n             }\n         },\n\n         _dispatch: function(e) {\n             //console.log(\"$.pm.dispatch\", e, this);\n             try {\n                 var msg = JSON.parse(e.data);\n             }\n             catch (ex) {\n                 console.warn(\"postmessage data invalid json: \", ex);\n                 return;\n             }\n             if (!msg.type) {\n                 console.warn(\"postmessage message type required\");\n                 return;\n             }\n             var cbs = pm.data(\"callbacks.postmessage\") || {},\n             cb = cbs[msg.type];\n             if (cb) {\n                 cb(msg.data);\n             }\n             else {\n                 var l = pm.data(\"listeners.postmessage\") || {};\n                 var fns = l[msg.type] || [];\n                 for (var i=0,len=fns.length; i<len; i++) {\n                     var o = fns[i];\n                     if (o.origin && o.origin !== '*' && e.origin !== o.origin) {\n                         console.warn(\"postmessage message origin mismatch\", e.origin, o.origin);\n                         if (msg.errback) {\n                             // notify post message errback\n                             var error = {\n                                 message: \"postmessage origin mismatch\",\n                                 origin: [e.origin, o.origin]\n                             };\n                             pm.send({target:e.source, data:error, type:msg.errback});\n                         }\n                         continue;\n                     }\n\n                     function sendReply ( data ) {\n                       if (msg.callback) {\n                           pm.send({target:e.source, data:data, type:msg.callback});\n                       }\n                     }\n                     \n                     try {\n                         if ( o.callback ) {\n                           o.fn(msg.data, sendReply, e);\n                         } else {\n                           sendReply ( o.fn(msg.data, e) );\n                         }\n                     }\n                     catch (ex) {\n                         if (msg.errback) {\n                             // notify post message errback\n                             pm.send({target:e.source, data:ex, type:msg.errback});\n                         } else {\n                             throw ex;\n                         }\n                     }\n                 };\n             }\n         }\n     };\n\n     // location hash polling\n     pm.hash = {\n\n         send: function(options, msg) {\n             //console.log(\"hash.send\", target_window, options, msg);\n             var target_window = options.target,\n             target_url = options.url;\n             if (!target_url) {\n                 console.warn(\"postmessage target window url is required\");\n                 return;\n             }\n             target_url = pm.hash._url(target_url);\n             var source_window,\n             source_url = pm.hash._url(window.location.href);\n             if (window == target_window.parent) {\n                 source_window = \"parent\";\n             }\n             else {\n                 try {\n                     for (var i=0,len=parent.frames.length; i<len; i++) {\n                         var f = parent.frames[i];\n                         if (f == window) {\n                             source_window = i;\n                             break;\n                         }\n                     };\n                 }\n                 catch(ex) {\n                     // Opera: security error trying to access parent.frames x-origin\n                     // juse use window.name\n                     source_window = window.name;\n                 }\n             }\n             if (source_window == null) {\n                 console.warn(\"postmessage windows must be direct parent/child windows and the child must be available through the parent window.frames list\");\n                 return;\n             }\n             var hashmessage = {\n                 \"x-requested-with\": \"postmessage\",\n                 source: {\n                     name: source_window,\n                     url: source_url\n                 },\n                 postmessage: msg\n             };\n             var hash_id = \"#x-postmessage-id=\" + pm._random();\n             target_window.location = target_url + hash_id + encodeURIComponent(JSON.stringify(hashmessage));\n         },\n\n         _regex: /^\\#x\\-postmessage\\-id\\=(\\w{32})/,\n\n         _regex_len: \"#x-postmessage-id=\".length + 32,\n\n         _bind: function() {\n             // are we already listening to message events on this w?\n             if (!pm.data(\"polling.postmessage\")) {\n                 setInterval(function() {\n                                 var hash = \"\" + window.location.hash,\n                                 m = pm.hash._regex.exec(hash);\n                                 if (m) {\n                                     var id = m[1];\n                                     if (pm.hash._last !== id) {\n                                         pm.hash._last = id;\n                                         pm.hash._dispatch(hash.substring(pm.hash._regex_len));\n                                     }\n                                 }\n                             }, $.pm.poll || 200);\n                 pm.data(\"polling.postmessage\", 1);\n             }\n         },\n\n         _dispatch: function(hash) {\n             if (!hash) {\n                 return;\n             }\n             try {\n                 hash = JSON.parse(decodeURIComponent(hash));\n                 if (!(hash['x-requested-with'] === 'postmessage' &&\n                       hash.source && hash.source.name != null && hash.source.url && hash.postmessage)) {\n                     // ignore since hash could've come from somewhere else\n                     return;\n                 }\n             }\n             catch (ex) {\n                 // ignore since hash could've come from somewhere else\n                 return;\n             }\n             var msg = hash.postmessage,\n             cbs = pm.data(\"callbacks.postmessage\") || {},\n             cb = cbs[msg.type];\n             if (cb) {\n                 cb(msg.data);\n             }\n             else {\n                 var source_window;\n                 if (hash.source.name === \"parent\") {\n                     source_window = window.parent;\n                 }\n                 else {\n                     source_window = window.frames[hash.source.name];\n                 }\n                 var l = pm.data(\"listeners.postmessage\") || {};\n                 var fns = l[msg.type] || [];\n                 for (var i=0,len=fns.length; i<len; i++) {\n                     var o = fns[i];\n                     if (o.origin) {\n                         var origin = /https?\\:\\/\\/[^\\/]*/.exec(hash.source.url)[0];\n                         if (o.origin !== '*' && origin !== o.origin) {\n                             console.warn(\"postmessage message origin mismatch\", origin, o.origin);\n                             if (msg.errback) {\n                                 // notify post message errback\n                                 var error = {\n                                     message: \"postmessage origin mismatch\",\n                                     origin: [origin, o.origin]\n                                 };\n                                 pm.send({target:source_window, data:error, type:msg.errback, hash:true, url:hash.source.url});\n                             }\n                             continue;\n                         }\n                     }\n\n                     function sendReply ( data ) {\n                       if (msg.callback) {\n                         pm.send({target:source_window, data:data, type:msg.callback, hash:true, url:hash.source.url});\n                       }\n                     }\n                     \n                     try {\n                         if ( o.callback ) {\n                           o.fn(msg.data, sendReply);\n                         } else {\n                           sendReply ( o.fn(msg.data) );\n                         }\n                     }\n                     catch (ex) {\n                         if (msg.errback) {\n                             // notify post message errback\n                             pm.send({target:source_window, data:ex, type:msg.errback, hash:true, url:hash.source.url});\n                         } else {\n                             throw ex;\n                         }\n                     }\n                 };\n             }\n         },\n\n         _url: function(url) {\n             // url minus hash part\n             return (\"\"+url).replace(/#.*$/, \"\");\n         }\n\n     };\n\n     $.extend(pm, {\n                  defaults: {\n                      target: null,  /* target window (required) */\n                      url: null,     /* target window url (required if no window.postMessage or hash == true) */\n                      type: null,    /* message type (required) */\n                      data: null,    /* message data (required) */\n                      success: null, /* success callback (optional) */\n                      error: null,   /* error callback (optional) */\n                      origin: \"*\",   /* postmessage origin (optional) */\n                      hash: false    /* use location hash for message passing (optional) */\n                  }\n              });\n\n })(this, typeof jQuery === \"undefined\" ? NO_JQUERY : jQuery);\n\n/**\n * http://www.JSON.org/json2.js\n **/\nif (! (\"JSON\" in window && window.JSON)){JSON={}}(function(){function f(n){return n<10?\"0\"+n:n}if(typeof Date.prototype.toJSON!==\"function\"){Date.prototype.toJSON=function(key){return this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\"};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf()}}var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;function quote(string){escapable.lastIndex=0;return escapable.test(string)?'\"'+string.replace(escapable,function(a){var c=meta[a];return typeof c===\"string\"?c:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+string+'\"'}function str(key,holder){var i,k,v,length,mind=gap,partial,value=holder[key];if(value&&typeof value===\"object\"&&typeof value.toJSON===\"function\"){value=value.toJSON(key)}if(typeof rep===\"function\"){value=rep.call(holder,key,value)}switch(typeof value){case\"string\":return quote(value);case\"number\":return isFinite(value)?String(value):\"null\";case\"boolean\":case\"null\":return String(value);case\"object\":if(!value){return\"null\"}gap+=indent;partial=[];if(Object.prototype.toString.apply(value)===\"[object Array]\"){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||\"null\"}v=partial.length===0?\"[]\":gap?\"[\\n\"+gap+partial.join(\",\\n\"+gap)+\"\\n\"+mind+\"]\":\"[\"+partial.join(\",\")+\"]\";gap=mind;return v}if(rep&&typeof rep===\"object\"){length=rep.length;for(i=0;i<length;i+=1){k=rep[i];if(typeof k===\"string\"){v=str(k,value);if(v){partial.push(quote(k)+(gap?\": \":\":\")+v)}}}}else{for(k in value){if(Object.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?\": \":\":\")+v)}}}}v=partial.length===0?\"{}\":gap?\"{\\n\"+gap+partial.join(\",\\n\"+gap)+\"\\n\"+mind+\"}\":\"{\"+partial.join(\",\")+\"}\";gap=mind;return v}}if(typeof JSON.stringify!==\"function\"){JSON.stringify=function(value,replacer,space){var i;gap=\"\";indent=\"\";if(typeof space===\"number\"){for(i=0;i<space;i+=1){indent+=\" \"}}else{if(typeof space===\"string\"){indent=space}}rep=replacer;if(replacer&&typeof replacer!==\"function\"&&(typeof replacer!==\"object\"||typeof replacer.length!==\"number\")){throw new Error(\"JSON.stringify\")}return str(\"\",{\"\":value})}}if(typeof JSON.parse!==\"function\"){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value===\"object\"){for(k in value){if(Object.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v}else{delete value[k]}}}}return reviver.call(holder,key,value)}cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})}if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver===\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")}}}());\n\n\n//# sourceURL=webpack:///./components/dropdown/node_modules/postmessage-polyfill/postmessage.js?");

/***/ }),

/***/ "./components/dropdown/node_modules/whatwg-fetch/fetch.js":
/*!****************************************************************!*\
  !*** ./components/dropdown/node_modules/whatwg-fetch/fetch.js ***!
  \****************************************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOMException\", function() { return DOMException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetch\", function() { return fetch; });\nvar global =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  (typeof global !== 'undefined' && global)\n\nvar support = {\n  searchParams: 'URLSearchParams' in global,\n  iterable: 'Symbol' in global && 'iterator' in Symbol,\n  blob:\n    'FileReader' in global &&\n    'Blob' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in global,\n  arrayBuffer: 'ArrayBuffer' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : ''\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get('Content-Type') &&\n        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n\n\n//# sourceURL=webpack:///./components/dropdown/node_modules/whatwg-fetch/fetch.js?");

/***/ }),

/***/ "./components/dropdown/umd/dropdown.development.js":
/*!*********************************************************!*\
  !*** ./components/dropdown/umd/dropdown.development.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? module.exports = factory(__webpack_require__(/*! coherent-gameface-components */ \"./components/dropdown/node_modules/coherent-gameface-components/components.js\")) :\n    undefined;\n}(this, (function (components) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var components__default = /*#__PURE__*/_interopDefaultLegacy(components);\n\n    var verticalTemplate = \"<div class=\\\"vertical-slider-wrapper\\\">\\n    <div class=\\\"vertical-arrow up\\\"><div class=\\\"arrow-up\\\"></div></div>\\n    <div class=\\\"vertical-slider\\\">\\n        <div class=\\\"vertical-handle handle\\\"></div>\\n    </div>\\n    <div class=\\\"vertical-arrow down\\\"><div class=\\\"arrow-down\\\"></div></div>\\n</div>\";\n\n    var horizontalTemplate = \"<div class=\\\"horizontal-slider-wrapper\\\">\\r\\n    <div class=\\\"horizontal-arrow up\\\"><div class=\\\"arrow-left\\\"></div></div>\\r\\n    <div class=\\\"horizontal-slider\\\">\\r\\n        <div class=\\\"horizontal-handle handle\\\"></div>\\r\\n    </div>\\r\\n    <div class=\\\"horizontal-arrow down\\\"><div class=\\\"arrow-right\\\"></div></div>\\r\\n</div>\";\n\n    var css = \"body {\\r\\n    background-color: #ebebeb;\\r\\n}\\r\\n\\r\\n.vertical-slider-wrapper {\\r\\n    height: 90vh;\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    max-width: 15px;\\r\\n}\\r\\n\\r\\n.vertical-arrow {\\r\\n    height: 15px;\\r\\n    width: 15px;\\r\\n    display: flex;\\r\\n    align-items: center;\\r\\n    justify-content: center;\\r\\n    background-color: #f1f1f1;\\r\\n}\\r\\n\\r\\n.vertical-arrow:hover {\\r\\n    background-color: #c1c1c1;\\r\\n}\\r\\n\\r\\n.arrow-up {\\r\\n    width: 0;\\r\\n    height: 0;\\r\\n    border-left: 5px solid transparent;\\r\\n    border-right: 5px solid transparent;\\r\\n\\r\\n    border-bottom: 5px solid #505050;\\r\\n}\\r\\n\\r\\n.arrow-down {\\r\\n    width: 0;\\r\\n    height: 0;\\r\\n    border-left: 5px solid transparent;\\r\\n    border-right: 5px solid transparent;\\r\\n\\r\\n    border-top: 5px solid #505050;\\r\\n}\\r\\n\\r\\n.vertical-slider {\\r\\n    background-color: #f1f1f1;\\r\\n    flex: 1;\\r\\n}\\r\\n\\r\\n.vertical-handle {\\r\\n    position: relative;\\r\\n    top: 0px;\\r\\n    left: 0px;\\r\\n    width: 100%;\\r\\n    height: 50px;\\r\\n    background-color: #c1c1c1;\\r\\n    cursor: pointer;\\r\\n}\\r\\n\\r\\n.vertical-handle:hover {\\r\\n    background-color: #787878;\\r\\n}\";\n\n    var css$1 = \"body {\\n    background-color: #ebebeb;\\n}\\n\\n.horizontal-slider-wrapper {\\n    width: 90vh;\\n    display: flex;\\n    flex-direction: row;\\n    max-height: 15px;\\n}\\n\\n.horizontal-arrow {\\n    height: 15px;\\n    width: 15px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    background-color: #f1f1f1;\\n}\\n\\n.arrow-right {\\n    width: 0;\\n    height: 0;\\n    border-top: 5px solid transparent;\\n    border-bottom: 5px solid transparent;\\n\\n    border-left: 5px solid #505050;\\n}\\n\\n.arrow-left {\\n    width: 0;\\n    height: 0;\\n    border-top: 5px solid transparent;\\n    border-bottom: 5px solid transparent;\\n\\n    border-right: 5px solid #505050;\\n}\\n\\n.horizontal-arrow:hover {\\n    background-color: #c1c1c1;\\n}\\n\\n.horizontal-slider {\\n    width: 90%;\\n    background-color: #f1f1f1;\\n}\\n\\n.horizontal-handle {\\n    position: relative;\\n    top: 0px;\\n    left: 0px;\\n    height: 100%;\\n    width: 50px;\\n    background-color: #c1c1c1;\\n    cursor: pointer;\\n}\\n\\n.horizontal-handle:hover {\\n    background-color: #787878;\\n}\";\n\n    const orientationUnitsNames = new Map([\r\n        ['vertical', {\r\n            mouseAxisCoords: 'clientY',\r\n            size: 'height',\r\n            sizePX: 'heightPX',\r\n            position: 'top',\r\n            scroll: 'scrollHeight',\r\n        }],\r\n        ['horizontal', {\r\n            mouseAxisCoords: 'clientX',\r\n            size: 'width',\r\n            sizePX: 'widthPX',\r\n            position: 'left',\r\n            scroll: 'scrollWidth',\r\n        }]\r\n    ]);\n\n    const customEvent = new MouseEvent ('click', );\n\n    /**\n     * @class Slider.\n     * Slider component; can be independently or as a building block of another\n     * component - for example a scrollbar. This is a custom slider control, do not\n     * confuse with the standard input type slider HTML element.\n    */\n    class Slider extends HTMLElement {\n        /**\n         * Set the position of the slider's handler.\n         * @param {number} value - the new value in percents.\n        */\n        set handlePosition (value) {\n            this._handlePosition = value;\n            // The names of the units vary depending on the orientation\n            // of the slider - width for horizontal, height for vertical etc.\n            this.handle.style[this.units.position] = value + '%';\n        }\n\n        /**\n         * Get the current position of the slider's handle in percents.\n         * @returns {number} - the value of the position.\n        */\n        get handlePosition () {\n            return this._handlePosition;\n        }\n\n        /**\n         * Get the current position of the slider's handle in pixels.\n         * @returns {number} - the value of the position.\n        */\n        get handlePositionPx() {\n            const sliderSize = this.slider.getBoundingClientRect()[this.units.size];\n            return this.handlePosition/100 * sliderSize;\n        }\n\n        /**\n         * Delay the execution of a callback function by n amount of frames.\n         * Used to retrieve the computed styles of elements.\n         * @param {Function} callback - the function that will be executed.\n         * @param {number} count - the amount of frames that the callback execution\n         * should be delayed by.\n        */\n        static waitForFrames(callback = () => {}, count = 3) {\n            if (count === 0) return callback();\n            count--;\n            requestAnimationFrame(() => this.waitForFrames(callback, count));\n        }\n\n        constructor() {\n            super();\n            // the amount of units that the slider will be updated\n            this.step = this.getAttribute('step') || 10;\n            // the initial position of the handle\n            this._handlePosition = 0;\n\n            // vertical or horizontal\n            this.orientation = this.getAttribute('orientation') || 'vertical';\n            // use the template for the current slider orientation\n            this.template = (this.orientation === 'vertical') ? verticalTemplate : horizontalTemplate;\n            // use the styles for the current slider orientation\n            const styles = (this.orientation === 'vertical') ? css : css$1;\n\n            // import the styles\n            components__default['default'].importStyleTag(`gameface-slider-${this.orientation}`, styles);\n\n            /**\n             * The names of the units are different for the two slider types.\n             * ['clientY', 'height', 'heightPX', 'top', 'scrollHeight] for vertical and\n             * ['clientX', 'width', 'widthPX', 'left', 'scrollWidth] for horizontal\n            */\n            this.units = orientationUnitsNames.get(this.orientation);\n\n            this.onSlideUp = (e) => { this.onSlideWithArrorws(-1); };\n            this.onSlideDown = (e) => { this.onSlideWithArrorws(1); };\n            this.onClick = this.onClick.bind(this);\n            this.onWheel = this.onWheel.bind(this);\n            this.onMouseDown = this.onMouseDown.bind(this);\n            this.onMouseMove = this.onMouseMove.bind(this);\n            this.onMouseUp = this.onMouseUp.bind(this);\n        }\n\n        /**\n         * Called when the element was attached to the DOM.\n        */\n        connectedCallback() {\n            // Load the template\n            components__default['default'].loadResource(this)\n                .then((result) => {\n                    this.template = result.template;\n                    // render the template\n                    components__default['default'].renderOnce(this);\n                    // do the initial setup - add event listeners, assign members\n                    this.setup();\n                })\n                .catch(err => console.error(err));\n        }\n\n        /**\n         * Set the slider and handle members and add event listeners.\n        */\n        setup() {\n            this.slider = this.getElementsByClassName(`${this.orientation}-slider`)[0];\n            this.handle = this.getElementsByClassName(`${this.orientation}-handle`)[0];\n\n            this.removeEventListeners();\n            this.attachEventListeners();\n        }\n\n        /**\n         * Gets the size of an element in px.\n         * Uses the computed styles which return the size in pixels as a string.\n         * @returns {number} - the size in pixels.\n        */\n        _getPxSizeWithoutUnits(element) {\n            let unitsName = this.units.sizePX;\n            if (!navigator.userAgent.includes('Cohtml')) unitsName = unitsName.substring(0, unitsName.length - 2);\n\n            const size = getComputedStyle(element)[unitsName];\n            return Number(size.substring(0, size.length - 2));\n        }\n\n        /**\n         * Update the size of the slider thumb.\n        */\n        resize(scrollableContainer) {\n            Slider.waitForFrames(() => {\n                // get the size of the whole slider element\n                const sliderWrapperSize = this._getPxSizeWithoutUnits(this.querySelector(`.${this.orientation}-slider-wrapper`));\n                // get the size of the up or down buttons in px\n                const controlsSize = this._getPxSizeWithoutUnits(this.querySelector(`.${this.orientation}-arrow`));\n                // get the combined size of the up and down buttons in % of the sliderWrapperSize\n                const controlsSizePercent = controlsSize * 2 / sliderWrapperSize * 100;\n\n                // get the size of the slider area\n                const sliderSize = this.slider.getBoundingClientRect()[this.units.size];\n                // get the size of the handle in percents relative to the current scroll(Height/Width)\n                const handleSizePercent = (sliderSize / scrollableContainer[this.units.scroll]) * 100;\n                // get the size of the handle in px; exclude the controlsSizePercent from the whole size\n                const handleSize = (sliderSize / (100 - controlsSizePercent)) * handleSizePercent;\n                // set the new size of the handle\n                this.handle.style[this.units.size] = handleSize + 'px';\n\n                this.scrollTo(this.handlePositionPx);\n            });\n        }\n\n        /**\n         * Remove event listeners.\n         */\n        removeEventListeners() {\n            // local listeners\n            this.slider.removeEventListener('click', this.onClick);\n            this.slider.removeEventListener('wheel', this.onWheel);\n            this.handle.removeEventListener('mousedown', this.onMouseDown);\n            this.querySelector('.up').removeEventListener('mousedown', this.onSlideUp);\n            this.querySelector('.down').removeEventListener('mousedown', this.onSlideDown);\n\n            // document listeners\n            document.removeEventListener('mousemove', this.onMouseMove);\n            document.removeEventListener('mouseup', this.onMouseUp);\n        }\n\n        /**\n         * Add event listeners to handle user interaction.\n        */\n        attachEventListeners() {\n            // local listeners\n            this.slider.addEventListener('click', this.onClick);\n            this.slider.addEventListener('wheel', this.onWheel);\n            this.handle.addEventListener('mousedown', this.onMouseDown);\n            this.querySelector('.up').addEventListener('mousedown', this.onSlideUp);\n            this.querySelector('.down').addEventListener('mousedown', this.onSlideDown);\n\n            // document listeners\n            document.addEventListener('mousemove', this.onMouseMove);\n            document.addEventListener('mouseup', this.onMouseUp);\n        }\n\n        /**\n         * Executed on mousedown. Moves the handle towards the position of the mouse\n         * with one step.\n         * @param {MouseEvent} event\n        */\n        onMouseDown(event) {\n            // set a flag to help the detection of drag\n            this.mousedown = true;\n            // get the bounding rectangles of the slider area and the handle\n            const handleRect = this.handle.getBoundingClientRect();\n            const sliderRect = this.slider.getBoundingClientRect();\n\n            // get the current position of the slider (top or left)\n            const sliderY = sliderRect[this.units.position];\n            // get the handle position within the slider's coordinates\n            const handleY = handleRect[this.units.position] - sliderY;\n            const mouseY = event[this.units.mouseAxisCoords] - sliderY;\n\n            // set the difference between the mouse click and the handle position\n            // used for better looking drag\n            this.delta = mouseY - handleY;\n        }\n\n        /**\n         * Called on mouseup.\n         * Resets the mousedown, dragging and slidingWithArrows properties\n         * and clears intervals.\n        */\n        onMouseUp() {\n            this.mousedown = false;\n            this.dragging = false;\n\n            if(this.slidingWithArrows) {\n                this.slidingWithArrows = false;\n                clearInterval(this.interval);\n            }\n        }\n\n        /**\n         * Called on mousemove.\n         * Detects dragging and scrolls to the current position of the mouse.\n         * @param {MouseEvent} event\n        */\n        onMouseMove(event) {\n            if(!this.mousedown) return\n            this.dragging = true;\n            const sliderRect = this.slider.getBoundingClientRect();\n            // get the mouse position within the slider coordinates\n            const mouseY = event[this.units.mouseAxisCoords] - sliderRect[this.units.position];\n            this.scrollTo(mouseY - this.delta);\n        }\n\n        /**\n         * Called when the arrow controls are used for sliding.\n         * Starts an interval and updates the slider position until mouseup occurs.\n         * @param {number} direction - 1 for down, -1 for up\n        */\n        onSlideWithArrorws(direction) {\n            this.slidingWithArrows = true;\n            this.interval = setInterval(() => this.scrollTo(this.getNextScrollPosition(direction, this.step)), 10);\n        }\n\n        /**\n         * Scrolls the a given position.\n         * @param {number} position\n        */\n        scrollTo(position){\n            const handleRect = this.handle.getBoundingClientRect();\n            const sliderRect = this.slider.getBoundingClientRect();\n\n            const handleSizePercent = (handleRect[this.units.size] / sliderRect[this.units.size]) * 100;\n            // new position in %\n            let newPosPercents = (position / sliderRect[this.units.size]) * 100;\n\n            // the slider range in percents is [0 - 100 - handleSizePercent]\n            // if the new position is outside of this range - snap the handle and\n            // scroll to the top or to the bottom\n            if (newPosPercents < 0) newPosPercents = 0;\n            if (newPosPercents + handleSizePercent > 100) newPosPercents = 100 - handleSizePercent;\n            this.handlePosition = newPosPercents;\n\n            //dispatch an event in case something needs to be done on scroll\n            this.dispatchEvent(new CustomEvent('slider-scroll', { detail: { handlePosition: newPosPercents } }));\n        }\n\n        /**\n         * Called on wheel event of the mouse.\n         * Scrolls the slider in the position of which the wheel is rotated\n         * @param {WheelEvent} event\n        */\n        onWheel(event) {\n            const direction = (event.deltaY < 0) ? -1 : 1;\n            this.scrollTo(this.getNextScrollPosition(direction, this.step));\n        }\n\n        /**\n         * Called on click of the mouse.\n         * Updated the handle's position with one step towards the position of the\n         * mouse click.\n         * @param {MouseEvent} event\n        */\n        onClick(event) {\n            if (event.target.classList.contains('handle')) return;\n            let direction = -1;\n            if (this.handle.getBoundingClientRect()[this.units.position] < event[this.units.mouseAxisCoords]) direction = 1;\n            this.scrollTo(this.getNextScrollPosition(direction, this.step));\n        }\n\n        /**\n         * Gets the next value of the scroll.\n         * @param {number} direction\n         * @param {number} step\n         * @returns {number} - the new scroll position\n        */\n        getNextScrollPosition(direction, step = this.step) {\n            // get the current scroll postition in px\n            const scrollTop = this.handlePosition * this.slider.getBoundingClientRect()[this.units.size] / 100;\n            return scrollTop + (direction * step);\n        }\n    }\n\n    components__default['default'].defineCustomElement('gameface-slider', Slider);\n\n    var template = \"<div class=\\\"wrapper\\\">\\n    <div class=\\\"scrollable-container\\\">\\n      <component-slot data-name=\\\"scrollable-content\\\"></component-slot>\\n    </div>\\n    <gameface-slider class=\\\"slider-component\\\" orientation=\\\"vertical\\\"></gameface-slider>\\n</div>\";\n\n    var css$2 = \"body {\\n    background-color: #ebebeb;\\n}\\n\\n.slider-component,\\n.vertical-slider-component {\\n    width: 10%;\\n    display: none;\\n}\\n\\n.wrapper {\\n    position: relative;\\n    width: 80vw;\\n    height: 90vh;\\n    display: flex;\\n    flex-direction: row;\\n}\\n\\n.scrollable-container {\\n    width: 90%;\\n    overflow: scroll;\\n    background-color: #ebebeb;\\n}\";\n\n    /**\n     * @class ScrollableContainer.\n     * Scrollable container. If it's content overflows a scrollbar will appear.\n    */\n    class ScrollableContainer extends HTMLElement {\n        constructor() {\n            super();\n            this.template = template;\n            this.isContainer = true;\n            components__default['default'].importStyleTag('scrollable-container', css$2);\n            this.url = '/components/scrollable-container/template.html';\n        }\n\n        /**\n         * Called when the element is attached to the DOM.\n        */\n        connectedCallback() {\n            // load the template\n            components__default['default'].loadResource(this)\n                .then((result) => {\n                    this.template = result.template;\n                    // render the component\n                    components__default['default'].render(this);\n                    // do the initial setup - add event listeners, assign members\n                    this.setup();\n                    this.shouldShowScrollbar();\n                })\n                .catch(err => console.error(err));\n        }\n\n        /**\n         * Set the scrollableContainer  and scrollbar members and attach event listeners.\n        */\n        setup() {\n            this.scrollableContainer = this.getElementsByClassName('scrollable-container')[0];\n            this.scrollbar = this.getElementsByClassName('slider-component')[0];\n\n            this.addEventListeners();\n        }\n\n        /**\n         * Add event listeners to handle resize, slider scroll\n         * and scroll of the scrollabe container.\n        */\n        addEventListeners() {\n            window.addEventListener('resize', () => this.scrollbar.resize(this.scrollableContainer));\n            this.scrollbar.addEventListener('slider-scroll', (e) => this.onScrollSlider(e));\n            this.scrollableContainer.addEventListener('scroll', (e) => this.onScroll(e));\n        }\n\n        /**\n         * Called on scroll event of the slider.\n         * @param {CustomEvent} event\n        */\n        onScrollSlider(event) {\n            // get the new scroll position in pixels\n            const scrollTop = event.detail.handlePosition * this.scrollableContainer.scrollHeight / 100;\n            // set the new scroll position\n            this.scrollableContainer.scrollTop = scrollTop;\n            // force a scroll event as setting scrollTop doesn't automatically emit it\n            this.scrollableContainer.dispatchEvent(new CustomEvent('scroll'));\n        }\n\n        /**\n         * Called on scroll event of the scrollable container.\n         */\n        onScroll() {\n            // get the scroll position in percents\n            this.scrollPos = (this.scrollableContainer.scrollTop / this.scrollableContainer.scrollHeight) * 100;\n            // set the position of the scrollbar handle\n            this.scrollbar.handlePosition = this.scrollPos;\n        }\n\n        /**\n         * Shows a scrollbar.\n         * @param {HTMLElement} scrollbar\n        */\n        showScrollBar(scrollbar) {\n            scrollbar.style.display = 'block';\n        }\n\n        /**\n         * Hides a scrollbar.\n         * @param {HTMLElement} scrollbar\n        */\n        hideScrollBar(scrollbar) {\n            scrollbar.style.display = 'none';\n        }\n\n        /**\n         * Checks if a scrollbar should be visible.\n        */\n        shouldShowScrollbar() {\n            const scrollableContent = this.querySelector('[data-name=\"scrollable-content\"]');\n\n            Slider.waitForFrames(() => {\n                const scrollableContentRect = scrollableContent.getBoundingClientRect();\n                const boundingRect = this.getBoundingClientRect();\n\n                if (scrollableContentRect.height <= boundingRect.height) return;\n                this.showScrollBar(this.scrollbar);\n                this.scrollbar.resize(this.scrollableContainer);\n            });\n        }\n    }\n    components__default['default'].defineCustomElement('scrollable-container', ScrollableContainer);\n\n    var template$1 = \"<div class=\\\"dropdown\\\">\\n    <div class=\\\"header\\\">\\n        <div class=\\\"selected\\\">Selected</div>\\n        <div class=\\\"custom-select-arrow\\\"></div>\\n    </div>\\n    <div class=\\\"options-container hidden\\\">\\n        <scrollable-container class=\\\"scrollable-container-component\\\">\\n            <div slot=\\\"scrollable-content\\\" data-name=\\\"scrollable-content\\\">\\n                <div class=\\\"options\\\">\\n                    <component-slot data-name=\\\"option\\\"></component-slot>\\n                </div>\\n            </div>\\n        </scrollable-container>\\n    </div>\\n</div>\";\n\n    var css$3 = \":root {\\n\\t--default-color-white: #fff;\\n\\t--default-color-blue: #25a5d6;\\n\\t--default-color-gray: #e6e6e6;\\n}\\n\\n/* Regular Elements */\\ninput, textarea, button, menu-item {\\n\\tborder-top-color: var(--default-color-blue);\\n\\tborder-right-color: var(--default-color-blue);\\n\\tborder-bottom-color: var(--default-color-blue);\\n\\tborder-left-color: var(--default-color-blue);\\n\\tbackground-color: var(--default-color-white);\\n}\\n\\nbutton, input[type=\\\"button\\\"] {\\n\\tbackground-color: var(--default-color-gray);\\n}\\n\\n/* Custom Components */\\ntab-heading, tab-panel, /* Tabs Component */\\n.modal, /* Modal Component */\\ngameface-menu,\\ngameface-right-menu,\\ngameface-left-menu,\\ngameface-bottom-menu\\n{\\n\\tborder-top-color: var(--default-color-blue);\\n\\tborder-right-color: var(--default-color-blue);\\n\\tborder-bottom-color: var(--default-color-blue);\\n\\tborder-left-color: var(--default-color-blue);\\n\\tbackground-color: var(--default-color-white);\\n}\\n\\ntab-heading.active {\\n\\tbackground-color: var(--default-color-gray);\\n}\\n\\n/* Modal Component  */\\n.header {\\n\\tborder-bottom-color: var(--default-color-blue);\\n}\\n\\n.close-x {\\n\\tbackground-color: var(--default-color-blue);\\n\\tcolor: var(--default-color-gray);\\n}\\n\\n.close-x:hover {\\n\\tbackground-color: var(--default-color-gray);\\n\\tcolor: var(--default-color-blue);\\n}\\n\\n/* Checkbox Component */\\n.checkbox-wrapper-inner {\\n\\tbackground-color: var(--default-color-white);\\n}\\n\\n.checkbox-background {\\n\\tborder-top-color: var(--default-color-gray);\\n\\tborder-right-color: var(--default-color-gray);\\n\\tborder-bottom-color: var(--default-color-gray);\\n\\tborder-left-color: var(--default-color-gray);\\n}\\n\\n.check-mark {\\n\\tbackground-color: var(--default-color-blue);\\n}\\n\";\n\n    var css$4 = \"dropdown-option {\\n    background-color: var(--default-color-white);\\n}\\n\\n.options {\\n    display: flex;\\n    flex-direction: column;\\n    background-color: var(--default-color-white);\\n    width: 150px;\\n}\\n\\n.header {\\n    align-items: center;\\n    display: flex;\\n}\\n\\n.selected {\\n    border: 2px solid transparent;\\n    display: flex;\\n    align-items: center;\\n    height: 30px;\\n    width: 150px;\\n    background-color: var(--default-color-white);\\n    padding: 0px 10px;\\n}\\n\\n.selected:hover {\\n    border: 2px solid;\\n    border-top-color: var(--default-color-blue);\\n    border-bottom-color: var(--default-color-blue);\\n    border-left-color: var(--default-color-blue);\\n    border-right-color: var(--default-color-blue);\\n}\\n\\n.options-container {\\n    height: 204px;\\n    width: 150px;\\n    border: 2px;\\n    border-style: solid;\\n    border-top-color: var(--default-color-blue);\\n    border-bottom-color: var(--default-color-blue);\\n    border-left-color: var(--default-color-blue);\\n    border-right-color: var(--default-color-blue);\\n}\\n\\ngameface-dropdown {\\n    width: 150px;\\n    position: relative;\\n    top: 10px;\\n    left: 10px;\\n    margin-left: 20px;\\n    display: flex;\\n    align-items: center;\\n}\\n\\n.full-width {\\n    width: 100%;\\n}\\n\\ngameface-dropdown * {\\n    box-sizing: border-box;\\n}\\n\\n.custom-select-arrow {\\n    position: absolute;\\n    right: 4px;\\n    width: 0;\\n    height: 0;\\n    border-left: 4px solid transparent;\\n    border-right: 4px solid transparent;\\n    border-top: 4px solid #000;\\n}\\n\\ndropdown-option {\\n    padding: 1px 4px;\\n}\\n\\n.disabled {\\n    color: var(--default-color-gray);\\n    pointer-events: none;\\n}\\n\\n.active {\\n    background-color: var(--default-color-blue);\\n}\\n\\n.hidden {\\n    display: none;\\n}\\n\\n.disable-hover{\\n    pointer-events: none;\\n}\";\n\n    const KEYCODES = components__default['default'].KEYCODES;\n\n    /**\n     * Checks if an element is descendant of another.\n     * @param {HTMLElement} parent\n     * @param {HTMLElement} child\n     * @returns {boolean}\n    */\n    function isDescendant(parent, child) {\n        var node = child.parentNode;\n        while (node != null) {\n            if (node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    }\n\n    class GamefaceDropdown extends HTMLElement {\n        constructor() {\n            super();\n\n            this.selectedOption = null;\n            this.isOpened = false;\n            // the index of the currently selected option element\n            this._selected = 0;\n            this._hovered = this._selected;\n            this.template = template$1;\n            this.onDocumentClick = this.onDocumentClick.bind(this);\n            this.onClickOption = this.onClickOption.bind(this);\n\n            components__default['default'].importStyleTag('gameface-dropdown-theme', css$3);\n            components__default['default'].importStyleTag('gameface-dropdown', css$4);\n        }\n\n        /**\n         * Returns the text content of the selected dropdown-option.\n         * @returns {String}\n        */\n        get value() {\n            if (this.selected) return this.selected.textContent;\n            return '';\n        }\n\n        /**\n         * Returns all dropdown-option elements.\n         * @returns {Array<HTMLElement>}\n        */\n        get allOptions() {\n            return Array.from(this.querySelectorAll('dropdown-option'));\n        }\n\n        /**\n         * Returns all dropdown-option elements that don't have attribute disabled.\n         * @returns {Array<HTMLElement>}\n        */\n        get enabledOptions() {\n            return this.allOptions.filter(option => !option.hasAttribute('disabled'));\n        }\n\n        /**\n         * Sets the currently selected option.\n         * Updates the class names of the current and the previously active options.\n         * Dispatches a change event to notify that the active option has been changed.\n        */\n        set selected(option) {\n            if (this.allOptions[this._selected]) {\n                this.allOptions[this._selected].classList.remove('active');\n            }\n\n            option.classList.add('active');\n            // get the index of the current option\n            this._selected = this.allOptions.indexOf(option);\n            this.hoveredElIndex = this._selected;\n\n            components__default['default'].transferContent(option.cloneNode(true), this.querySelector('.selected'));\n\n            // dispatch a change event\n            this.dispatchEvent(new CustomEvent('change', {\n                detail: {\n                    target: option\n                }\n            }));\n        }\n\n        /**\n         * Sets the currently hovered element's index.\n         * @param {Number} value\n        */\n        set hoveredElIndex(value) {\n            if (!this.allOptions[value]) return;\n            return this._hovered = value;\n        }\n\n         /**\n         * Returns the currently hovered element's index.\n         * @returns {Number}\n        */\n        get hoveredElIndex() {\n            return this._hovered;\n        }\n\n        /**\n         * Returns the currently selected option element.\n         * @returns {HTMLElement}\n        */\n        get selected() {\n            return this.allOptions[this._selected];\n        }\n\n        connectedCallback() {\n            components__default['default'].loadResource(this)\n                .then((result) => {\n                    this.template = result.template;\n                    components__default['default'].renderOnce(this);\n                    // make this element focusable\n                    this.setAttribute('tabindex', '1');\n                    // select the default element\n                    this.selected = this.enabledOptions[this._selected];\n                    this.attachEventListeners();\n                })\n                .catch(err => console.error(err));\n        }\n\n        /**\n         * Called on document click.\n         * Closes the options panel if it's opened.\n         * @param {MouseEvent} event - the current event object.\n        */\n        onDocumentClick(event) {\n            if (event.target === this || isDescendant(this, event.target)) return;\n            if (this.isOpened) this.closeOptionsPanel();\n        }\n\n        /**\n         * Focuses an option from the enabledOptions list.\n         * Uses the index of the enabled option to find the index of the same option\n         * in the full list.\n         * @param {number} newIndex - the index of the enabled option.\n        */\n        focusEnabledOption(newIndex) {\n            const nextOptionIdx = this.allOptions.indexOf(this.enabledOptions[newIndex]);\n            this.focusOption(nextOptionIdx);\n        }\n\n        /**\n         * Focuses an option by index. Updates the index of the hovered element.\n         * @param {number} nextOptionIdx - the index of the option that has to be focused.\n        */\n        focusOption(nextOptionIdx) {\n            this.allOptions[this.hoveredElIndex].classList.remove('active');\n\n            this.selected = this.allOptions[nextOptionIdx];\n            this.hoveredElIndex = nextOptionIdx;\n        }\n\n        /**\n         * Returns the index of the next option element.\n         * Wraps around if it reaches the end of the list.\n         * @param {Number} currentOptionIndx - the index of the currently active option\n         * @returns {Number} - the index of the next enabled option\n        */\n        getNextOptionIndex(currentOptionIndx) {\n            return (currentOptionIndx + 1) % this.enabledOptions.length;\n        }\n\n        /**\n         * Returns the index of the previous option element.\n         * Wraps around if it reaches the start of the list.\n         * @param {Number} currentOptionIndx - the index of the currently active option\n         * @returns {Number} - the index of the previous enabled option\n        */\n        getPreviousOptionIndex(currentOptionIndx) {\n            const enabledOptionLength = this.enabledOptions.length;\n            return ((currentOptionIndx - 1) + enabledOptionLength) % enabledOptionLength;\n        }\n\n        /**\n         * Called on keydown. Used to handle option selection via the keyboard.\n         * @param {KeyboardEvent} event - the current event object\n        */\n        onKeydown(event) {\n            const currentOptionIndex = this.enabledOptions.indexOf(this.allOptions[this.hoveredElIndex]);\n\n            switch (event.keyCode) {\n                case KEYCODES.ENTER:\n                    this.focusOption(this.hoveredElIndex);\n                    this.closeOptionsPanel();\n                    return;\n                case KEYCODES.TAB:\n                case KEYCODES.ESCAPE:\n                    this.closeOptionsPanel();\n                    return;\n                case KEYCODES.HOME:\n                    // focus first\n                    this.focusEnabledOption(0);\n                    break;\n                case KEYCODES.END:\n                    // focus last\n                    this.focusEnabledOption(this.enabledOptions.length - 1);\n                    break;\n                case KEYCODES.UP:\n                case KEYCODES.LEFT:\n                    this.focusEnabledOption(this.getPreviousOptionIndex(currentOptionIndex));\n                    break;\n                case KEYCODES.DOWN:\n                case KEYCODES.RIGHT:\n                    this.focusEnabledOption(this.getNextOptionIndex(currentOptionIndex));\n                    break;\n            }\n\n            this.scrollToSelectedElement();\n        }\n\n        /**\n         * Checks if the current user agent is Cohtml\n        */\n        isGameface() {\n            return navigator.userAgent.match('Cohtml');\n        }\n\n        /**\n         * Called on click on the select element.\n         * Toggles the options panel, shows the scrollbar and scrolls to\n         * the selected option element.\n        */\n        onClick() {\n            const scrollableContainer = this.querySelector('scrollable-container');\n\n            if (this.isOpened) {\n                this.closeOptionsPanel();\n                return;\n            }\n\n            if (!this.isGameface()) {\n                scrollableContainer.querySelector('.scrollable-container').classList.add('full-width');\n            } else if (this.isGameface()){\n                scrollableContainer.shouldShowScrollbar();\n            }\n\n            this.scrollToSelectedElement();\n            this.openOptionsPanel();\n        }\n\n        /**\n         * Attaches event listeners.\n        */\n        attachEventListeners() {\n            // handle keyboard\n            this.addEventListener('keydown', (event) => this.onKeydown(event));\n\n            // handle click on the select element\n            const selectedElementPlaceholder = this.querySelector('.selected');\n            selectedElementPlaceholder.addEventListener('click', (event) => this.onClick(event));\n\n            // handle click on the option elements\n            const options = this.querySelectorAll('dropdown-option');\n            for (let i = 0; i < options.length; i++) {\n                options[i].addEventListener('selected-option', (event) => this.onClickOption(event));\n                options[i].addEventListener('mouseover', (event) => this.onMouseOverOption(event));\n                options[i].addEventListener('mouseout', (event) => {\n                    event.target.classList.remove('active');\n                });\n            }\n        }\n\n        /**\n         * Called on mouseover an option element.\n         * @param {MouseEvent} event - the current event object.\n        */\n        onMouseOverOption(event) {\n            const options = this.allOptions;\n            const index = options.indexOf(event.target);\n\n            this.selected.classList.remove('active');\n            event.target.classList.add('active');\n            this.hoveredElIndex = index;\n        }\n\n        /**\n         * Called when an option element is clicked.\n         * Updates the selected member and closes the options panel.\n         * @param {MouseEvent} event - the current event object.\n        */\n        onClickOption(event) {\n            this.selected = event.target;\n            this.closeOptionsPanel();\n        }\n\n        /**\n         * Hides the options panel.\n        */\n        closeOptionsPanel() {\n            const optionsPanel = this.querySelector('.options-container');\n            this.isOpened = false;\n            optionsPanel.classList.add('hidden');\n            document.removeEventListener('click', this.onDocumentClick);\n        }\n\n        /**\n         * Shows the options panel.\n         * Adds the active class to the currently selected option.\n         * Focuses the dropdown element.\n        */\n        openOptionsPanel() {\n            this.selected.classList.add('active');\n            const optionsPanel = this.querySelector('.options-container');\n            this.isOpened = true;\n            optionsPanel.classList.remove('hidden');\n            this.focus();\n            document.addEventListener('click', this.onDocumentClick);\n        }\n\n        /**\n         * Sets the selected element of the dropdown and scrolls to it.\n         * @param {DropdownOption} - the option element.\n        */\n        setSelected(element) {\n            this.selected = element;\n            this.scrollToSelectedElement();\n        }\n\n        /**\n         * Scrolls to the selected option element.\n        */\n        scrollToSelectedElement() {\n            const scrollbleContainer = this.querySelector('.scrollable-container');\n            const option = this.querySelector('dropdown-option');\n            const optionSize = option.getBoundingClientRect().height;\n\n            // the scroll position in pixels is equal to the height of the selected\n            // option multiplied by its index\n            clearTimeout(this.timeout);\n            document.body.classList.add('disable-hover');\n            let scrollInPX = this.hoveredElIndex * optionSize;\n            scrollbleContainer.scrollTop = scrollInPX;\n            scrollbleContainer.dispatchEvent(new CustomEvent('scroll'));\n\n            this.timeout = setTimeout(() => {\n                document.body.classList.remove('disable-hover');\n            }, 500);\n        }\n    }\n\n    class DropdownOption extends HTMLElement {\n        static get observedAttributes() {\n            return ['disabled'];\n        }\n\n        /**\n         * Called when an attribute changes\n        */\n        attributeChangedCallback() {\n            if (this.hasAttribute('disabled')) {\n                this.classList.add('disabled');\n                this.removeEventListener('click', this.onClick);\n            } else {\n                this.classList.remove('disabled');\n                this.addEventListener('click', this.onClick);\n            }\n        }\n\n        constructor() {\n            super();\n            this.attributeChangedCallback();\n        }\n\n        onClick(event) {\n            event.target.dispatchEvent(new CustomEvent('selected-option'));\n        }\n    }\n\n    components__default['default'].defineCustomElement('dropdown-option', DropdownOption);\n    components__default['default'].defineCustomElement('gameface-dropdown', GamefaceDropdown);\n\n    return GamefaceDropdown;\n\n})));\n\n\n//# sourceURL=webpack:///./components/dropdown/umd/dropdown.development.js?");

/***/ })

/******/ });